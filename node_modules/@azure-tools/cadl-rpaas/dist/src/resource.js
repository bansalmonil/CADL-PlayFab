import { getDoc, getIntrinsicType, isIntrinsic, } from "@cadl-lang/compiler";
import { reportDiagnostic } from "./lib.js";
import { getArmNamespace } from "./namespace.js";
import { generateStandardOperations } from "./operations.js";
const ExpectedProvisioningStates = ["Succeeded", "Failed", "Canceled"];
function getPathParameterInfo(program, paramType, resourceType) {
    if (paramType.kind !== "Model") {
        reportDiagnostic(program, { code: "path-parameter-type", target: paramType });
        return undefined;
    }
    if (paramType.properties.size !== 1) {
        reportDiagnostic(program, {
            code: "path-parameter-type",
            messageId: "singleProp",
            target: paramType,
        });
        return undefined;
    }
    const paramName = paramType.properties.keys().next().value;
    const propType = paramType.properties.get(paramName);
    if (getIntrinsicType(program, propType) !== "string") {
        reportDiagnostic(program, {
            code: "path-parameter-type",
            messageId: "string",
            target: propType,
        });
        return undefined;
    }
    return {
        name: paramName,
        typeName: paramType.name,
        description: propType ? getDoc(program, propType) : "",
        resourceType,
    };
}
function getPathParameters(program, pathParameters) {
    const parameters = [];
    for (const p of pathParameters) {
        const info = getPathParameterInfo(program, p);
        if (info) {
            parameters.push(info);
        }
    }
    return parameters;
}
const armResourceNamespacesKey = Symbol();
export function getArmResources(program) {
    return Array.from(program.stateMap(armResourceNamespacesKey).keys()).map((r) => r);
}
export function getArmResourceInfo(program, resourceType) {
    if (resourceType.kind !== "Model") {
        reportDiagnostic(program, { code: "decorator-wrong-type", target: resourceType });
        return undefined;
    }
    const resourceInfo = program.stateMap(armResourceNamespacesKey).get(resourceType);
    if (!resourceInfo) {
        reportDiagnostic(program, {
            code: "arm-resource-missing",
            format: { type: resourceType.name },
            target: resourceType,
        });
    }
    return resourceInfo;
}
function getRequiredPropertyValue(program, model, propertyName, valueKind) {
    const value = getPropertyValue(program, model, propertyName, valueKind);
    if (!value) {
        reportDiagnostic(program, {
            code: "missing-required-prop",
            format: { propertyName },
            target: model,
        });
    }
    return value;
}
function getPropertyValue(program, model, propertyName, valueKind) {
    const prop = model.properties.get(propertyName);
    if (prop) {
        if (prop.type.kind === valueKind) {
            return prop.type;
        }
        else {
            reportDiagnostic(program, {
                code: "invalid-type-prop",
                format: { type: prop.type.kind, valueType: valueKind },
                target: prop.type,
            });
        }
    }
    return undefined;
}
export function $armResource(program, resourceType, resourceDetails) {
    var _a, _b, _c, _d, _e, _f;
    if (resourceDetails.kind !== "Model") {
        reportDiagnostic(program, {
            code: "decorator-param-wrong-type",
            messageId: "armResource",
            target: resourceType,
        });
        return;
    }
    if (resourceType.kind !== "Model") {
        reportDiagnostic(program, {
            code: "decorator-wrong-type",
            messageId: "armResource",
            target: resourceType,
        });
        return;
    }
    if (!resourceType.namespace) {
        reportDiagnostic(program, {
            code: "decorator-in-namespace",
            format: { decoratorName: "armResource" },
            target: resourceType,
        });
        return;
    }
    if (resourceType.name.includes("_")) {
        reportDiagnostic(program, { code: "no-underscore-in-operation-name", target: resourceType });
        return;
    }
    const resourcePathType = getRequiredPropertyValue(program, resourceDetails, "path", "String");
    const collectionNameType = getRequiredPropertyValue(program, resourceDetails, "collectionName", "String");
    let resourceParamType = getRequiredPropertyValue(program, resourceDetails, "parameterType", "Model");
    // Special case: passing 'null' for the parameter type clears it
    if (isIntrinsic(program, resourceParamType) && (resourceParamType === null || resourceParamType === void 0 ? void 0 : resourceParamType.name) === "null") {
        resourceParamType = undefined;
    }
    const parentResourceType = getPropertyValue(program, resourceDetails, "parentResourceType", "Model");
    let standardOperations = ["read", "create", "update", "delete", "list"];
    const operationsValue = getPropertyValue(program, resourceDetails, "standardOperations", "Tuple");
    if (operationsValue) {
        standardOperations = operationsValue.values.map((v) => {
            if (v.kind !== "String") {
                reportDiagnostic(program, {
                    code: "decorator-param-wrong-type",
                    messageId: "armResourceStandardOperation",
                    target: resourceType,
                });
                return "";
            }
            return v.value;
        });
    }
    if (resourceParamType && resourceParamType.kind !== "Model") {
        reportDiagnostic(program, {
            code: "decorator-param-wrong-type",
            messageId: "armResourceParameterType",
            target: resourceType,
        });
        return;
    }
    const pathParameterTypes = getPropertyValue(program, resourceDetails, "pathParameters", "Tuple");
    // Locate the ARM namespace in the namespace hierarchy
    let armNamespace = getArmNamespace(program, resourceType.namespace);
    if (!armNamespace) {
        reportDiagnostic(program, { code: "arm-resource-missing-arm-namespace", target: resourceType });
        return;
    }
    // Create the resource model type and evaluate it
    const resourceModelName = resourceType.name;
    const resourceListModelName = `${resourceModelName}ListResult`;
    const resourceNameParam = resourceParamType
        ? getPathParameterInfo(program, resourceParamType, resourceType)
        : undefined;
    const parentNamespace = program.checker.getNamespaceString(resourceType.namespace);
    // Detect the resource and properties types
    let resourceKind = "Plain";
    let propertiesType = undefined;
    if (resourceType.baseModel) {
        const coreType = resourceType.baseModel;
        if (coreType.kind === "Model") {
            // There are two possibilities here:
            // 1. Resource defined with `model is`, look for `properties` property
            // 2. Resource defined with `model extends`, look for properties type in template args
            if (((_a = coreType.templateArguments) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                propertiesType = (_b = coreType.templateArguments) === null || _b === void 0 ? void 0 : _b[0];
            }
            else {
                const propertiesProperty = (_c = resourceType.properties) === null || _c === void 0 ? void 0 : _c.get("properties");
                propertiesType = propertiesProperty === null || propertiesProperty === void 0 ? void 0 : propertiesProperty.type;
            }
            if (!propertiesType || propertiesType.kind !== "Model") {
                reportDiagnostic(program, {
                    code: "decorator-param-wrong-type",
                    messageId: "armResourceResourceProperty",
                    target: resourceType,
                });
            }
            // This will find either TrackedResource<T> or TrackedResourceBase
            if (coreType.name.startsWith("TrackedResource")) {
                const provisioningStateProperty = propertiesType.properties.get("provisioningState");
                if (!provisioningStateProperty || provisioningStateProperty.type.kind !== "Enum") {
                    reportDiagnostic(program, {
                        code: "tracked-resource-provisioning-state",
                        messageId: "missing",
                        target: resourceType,
                    });
                    return;
                }
                // Check the enum for the mandatory provisioning state values
                const enumValues = new Set(provisioningStateProperty.type.members.map((m) => m.name));
                const missingStates = ExpectedProvisioningStates.filter((v) => !enumValues.has(v));
                if (missingStates.length > 0) {
                    reportDiagnostic(program, {
                        code: "tracked-resource-provisioning-state",
                        messageId: "wrongType",
                        format: {
                            name: provisioningStateProperty.type.name,
                            missingStates: missingStates.join(","),
                        },
                        target: resourceType,
                    });
                    return;
                }
                resourceKind = "Tracked";
            }
            else if (coreType.name.startsWith("ProxyResource")) {
                resourceKind = "Proxy";
            }
            else if (coreType.name.startsWith("ExtensionResource")) {
                resourceKind = "Extension";
            }
        }
    }
    const armResourceInfo = {
        armNamespace: armNamespace !== null && armNamespace !== void 0 ? armNamespace : "",
        parentNamespace,
        resourceKind,
        propertiesType,
        collectionName: (_d = collectionNameType === null || collectionNameType === void 0 ? void 0 : collectionNameType.value) !== null && _d !== void 0 ? _d : "",
        parentResourceType,
        standardOperations,
        resourceNameParam,
        resourceModelName,
        resourceListModelName,
        operationNamespaces: new Set(),
    };
    armResourceInfo.resourcePath = getResourcePath(program, armResourceInfo, resourceType, resourcePathType === null || resourcePathType === void 0 ? void 0 : resourcePathType.value, pathParameterTypes ? pathParameterTypes.values : []);
    program.stateMap(armResourceNamespacesKey).set(resourceType, armResourceInfo);
    const finalPath = armResourceInfo.resourceNameParam
        ? `${(_e = armResourceInfo.resourcePath) === null || _e === void 0 ? void 0 : _e.path}/{${armResourceInfo.resourceNameParam.name}}`
        : (_f = armResourceInfo.resourcePath) === null || _f === void 0 ? void 0 : _f.path;
    // Prepare the namespace for the operation group
    program.evalCadlScript(`
      using Azure.ARM;
      namespace ${armResourceInfo.parentNamespace} {
        @doc("The response of a ${armResourceInfo.resourceModelName} list operation.")
        model ${armResourceInfo.resourceListModelName} extends Page<${armResourceInfo.resourceModelName}> { };

        @resource("${finalPath}")
        @tag("${armResourceInfo.collectionName}")
        namespace ${armResourceInfo.collectionName} {
        }
      }
  `);
    generateStandardOperations(program, resourceType, armResourceInfo.standardOperations);
}
function getDefaultResourcePath(resourceInfo) {
    if (resourceInfo.resourceKind === "Extension") {
        return {
            path: `/{resourceUri}/providers/${resourceInfo.armNamespace}`,
            parameters: [
                {
                    name: "resourceUri",
                    typeName: "ResourceUriParameter",
                    description: "The uri of the target resource",
                },
            ],
        };
    }
    else {
        return {
            path: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/${resourceInfo.armNamespace}`,
            parameters: [
                {
                    name: "subscriptionId",
                    typeName: "SubscriptionIdParameter",
                    description: "The subscription containing the resource.",
                },
                {
                    name: "resourceGroupName",
                    typeName: "ResourceGroupNameParameter",
                    description: "The resource group containing the resource.",
                },
            ],
        };
    }
}
function appendResourcePath(basePath, newPath) {
    basePath.path = basePath.path.length > 0 ? `${basePath.path}/${newPath.path}` : newPath.path;
    basePath.parameters = [...basePath.parameters, ...newPath.parameters];
}
function getResourcePath(program, armResourceInfo, resourceType, resourcePath, pathParameterTypes) {
    if (!resourcePath) {
        return undefined;
    }
    let armResourcePath;
    if (armResourceInfo.parentResourceType) {
        const parentResourceInfo = getArmResourceInfo(program, armResourceInfo.parentResourceType);
        if (!parentResourceInfo) {
            return undefined;
        }
        if (!parentResourceInfo.resourcePath) {
            reportDiagnostic(program, {
                code: "parent-type",
                messageId: "missingResourcePath",
                target: resourceType,
            });
            return undefined;
        }
        if (!parentResourceInfo.resourceNameParam) {
            reportDiagnostic(program, {
                code: "parent-type",
                messageId: "missingResourceName",
                target: resourceType,
            });
            return undefined;
        }
        armResourcePath = {
            path: `${parentResourceInfo.resourcePath.path}/{${parentResourceInfo.resourceNameParam.name}}`,
            parameters: [
                ...parentResourceInfo.resourcePath.parameters,
                parentResourceInfo.resourceNameParam,
            ],
        };
    }
    else if (resourcePath[0] !== "/") {
        armResourcePath = getDefaultResourcePath(armResourceInfo);
    }
    else {
        armResourcePath = {
            path: "",
            parameters: [],
        };
    }
    appendResourcePath(armResourcePath, {
        path: resourcePath,
        parameters: getPathParameters(program, pathParameterTypes),
    });
    return armResourcePath;
}
//# sourceMappingURL=resource.js.map