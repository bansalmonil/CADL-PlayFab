import { EventEmitter, getDoc, isIntrinsic, navigateProgram, SyntaxKind, } from "@cadl-lang/compiler";
import { reportDiagnostic } from "./lib.js";
export async function $onBuild(p) {
    runLinter(p);
}
function isInlineModel(target) {
    return !target.name;
}
/**
 *
 *@param target
 *@returns true if the model type is a model with template declaration.
 */
function isTemplateDeclarationType(target) {
    var _a;
    return ((_a = target.node) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.ModelStatement && target.node.templateParameters.length;
}
function createListenerOnGeneralType(fn) {
    const listener = {
        namespace: fn,
        interface: fn,
        operation: fn,
        model: fn,
        modelProperty: fn,
        templateParameter: fn,
        enum: fn,
        union: fn,
        unionVariant: fn,
        array: fn,
        tuple: fn,
    };
    return listener;
}
class Linter {
    constructor() {
        this.eventEmitter = new EventEmitter();
    }
    run(p) {
        navigateProgram(p, this.eventEmitter);
    }
    register(listeners) {
        const listenerList = Array.isArray(listeners) ? listeners : [listeners];
        for (const listeners of listenerList) {
            for (const [name, listener] of Object.entries(listeners)) {
                this.eventEmitter.on(name, listener);
            }
        }
    }
}
const runLinter = (p) => {
    const checkDocumentation = {
        operation: (context) => {
            if (!getDoc(p, context)) {
                reportDiagnostic(p, { code: "operation-requires-documentation", target: context });
            }
        },
        model: (context) => {
            // it's by design that the `getDoc` function can't get the `doc` for template declaration type.
            if (!isIntrinsic(p, context) &&
                !isTemplateDeclarationType(context) &&
                !isInlineModel(context)) {
                if (!getDoc(p, context)) {
                    reportDiagnostic(p, { code: "model-requires-documentation", target: context });
                }
                for (const prop of context.properties.values()) {
                    if (!getDoc(p, prop)) {
                        reportDiagnostic(p, { code: "property-requires-documentation", target: context });
                    }
                }
            }
        },
    };
    const isDocumentationSameAsNodeName = (target) => {
        const docText = getDoc(p, target);
        const nodeName = target.name;
        if (typeof docText === "string" &&
            typeof nodeName === "string" &&
            docText.trim().toLowerCase() === nodeName.toLowerCase()) {
            reportDiagnostic(p, { code: "documentation-different-with-node-name", target });
        }
    };
    const checkDocumentationText = createListenerOnGeneralType(isDocumentationSameAsNodeName);
    const checkInlineModel = {
        model: (context) => {
            // the empty model'{}' can be ignored.
            if (isInlineModel(context) && context.properties.size > 0) {
                reportDiagnostic(p, { code: "no-inline-model", target: context });
            }
        },
    };
    const linter = new Linter();
    linter.register([checkInlineModel, checkDocumentation, checkDocumentationText]);
    return linter.run(p);
};
//# sourceMappingURL=linter.js.map