import { $resource } from "@cadl-lang/rest";
import { reportDiagnostic } from "./lib.js";
import { getArmResourceInfo } from "./resource.js";
const standardOperationFunctions = {
    read: armStandardRead,
    create: armStandardCreate,
    update: armStandardUpdate,
    delete: armStandardDelete,
    list: armStandardList,
};
const resourceOperationNamespaces = new Map();
export function $armResourceOperations(program, target, resourceType) {
    if (target.kind !== "Namespace") {
        reportDiagnostic(program, {
            code: "decorator-wrong-type",
            messageId: "armResourceOperations",
            target,
        });
        return;
    }
    // Verify that this is a registered resource
    const armResourceInfo = getArmResourceInfo(program, resourceType);
    if (!armResourceInfo) {
        return;
    }
    if (!armResourceInfo.resourcePath) {
        reportDiagnostic(program, { code: "arm-resource-operations-with-resource-path", target });
        return;
    }
    armResourceInfo.operationNamespaces.add(target.name);
    // Set the resource path
    $resource(program, target, armResourceInfo.resourcePath.path);
    // Remember this namespace
    resourceOperationNamespaces.set(target, resourceType);
}
export function armResourceParams(program, operation) {
    if (operation.kind !== "Operation") {
        reportDiagnostic(program, {
            code: "decorator-wrong-type",
            messageId: "armOperation",
            target: operation,
        });
        return;
    }
    if (!operation.namespace) {
        reportDiagnostic(program, {
            code: "decorator-in-namespace",
            format: { decoratorName: "armOperation" },
            target: operation,
        });
        return;
    }
    const resourceType = resourceOperationNamespaces.get(operation.namespace);
    if (!resourceType) {
        reportDiagnostic(program, {
            code: "arm-operation-in-namespace-with-resource-operations",
            target: operation,
        });
        return;
    }
    // TODO: Automatically add base parameters
}
const apiVersionParameter = {
    name: "apiVersion",
    typeName: "ApiVersionParameter",
    description: "The service API Version",
};
function getOperationPathArguments(pathParameters) {
    return [apiVersionParameter, ...pathParameters].map((param) => `...${param.typeName}`).join(", ");
}
function prepareOperationInfo(program, decoratorName, resourceType, operationGroup) {
    const armResourceInfo = getArmResourceInfo(program, resourceType);
    if (!armResourceInfo) {
        return;
    }
    if (!armResourceInfo.resourcePath) {
        reportDiagnostic(program, {
            code: "decorator-with-resource-path",
            format: {
                decoratorName,
            },
            target: resourceType,
        });
        return;
    }
    const nameParamList = armResourceInfo.resourceNameParam
        ? [armResourceInfo.resourceNameParam]
        : [];
    const operationParams = [...armResourceInfo.resourcePath.parameters, ...nameParamList];
    operationGroup = operationGroup !== null && operationGroup !== void 0 ? operationGroup : armResourceInfo.collectionName;
    return {
        armResourceInfo,
        operationParams,
        namespace: `${armResourceInfo.parentNamespace}.${operationGroup}`,
    };
}
function evalInNamespace(program, namespace, cadlScript) {
    program.evalCadlScript(`
    using Azure.ARM;
    namespace ${namespace} {
      ${cadlScript}
    }
  `);
}
export function armStandardRead(program, target, documentation) {
    var _a;
    const info = prepareOperationInfo(program, "armStandardRead", target);
    if (!info) {
        return;
    }
    const { armResourceInfo, operationParams, namespace } = info;
    (_a = armResourceInfo.operationNamespaces) === null || _a === void 0 ? void 0 : _a.add(namespace);
    if (!documentation) {
        documentation = `Get a ${armResourceInfo.resourceModelName}`;
    }
    evalInNamespace(program, namespace, `@doc("${documentation}")
     @get op Get(${getOperationPathArguments(operationParams)}): ArmResponse<${armResourceInfo.resourceModelName}> | ErrorResponse;`);
}
export function armStandardCreate(program, target, documentation) {
    var _a;
    const info = prepareOperationInfo(program, "armStandardCreate", target);
    if (!info) {
        return;
    }
    const { armResourceInfo, operationParams, namespace } = info;
    (_a = armResourceInfo.operationNamespaces) === null || _a === void 0 ? void 0 : _a.add(namespace);
    if (!documentation) {
        documentation = `Create a ${armResourceInfo.resourceModelName}`;
    }
    const lroFinalState = "azure-async-operation";
    evalInNamespace(program, namespace, `@doc("${documentation}")
       @extension("x-ms-long-running-operation", true)
       @asyncOperationOptions("${lroFinalState}")
       @put op CreateOrUpdate(${getOperationPathArguments(operationParams)}, 
       @doc("Resource create parameters.")
       @body resource: ${armResourceInfo.resourceModelName}): ArmResponse<${armResourceInfo.resourceModelName}> | ArmCreatedResponse<${armResourceInfo.resourceModelName}> | ErrorResponse;`);
}
export function armStandardUpdate(program, target, documentation) {
    var _a;
    const info = prepareOperationInfo(program, "armStandardUpdate", target);
    if (!info) {
        return;
    }
    const { armResourceInfo, operationParams, namespace } = info;
    (_a = armResourceInfo.operationNamespaces) === null || _a === void 0 ? void 0 : _a.add(namespace);
    if (!documentation) {
        documentation = `Update a ${armResourceInfo.resourceModelName}`;
    }
    // Generate a special "Update" model type using the resource's properties type
    let updateModelName = `${armResourceInfo.resourceModelName}`;
    if (armResourceInfo.propertiesType) {
        updateModelName = `${armResourceInfo.resourceModelName}Update`;
        const updatePropertiesModel = `${updateModelName}Properties`;
        const updatePropertiesDescription = `@doc("The updateable properties of ${armResourceInfo.propertiesType.name}")`;
        const propertiesModelString = `${updatePropertiesDescription}
        model ${updatePropertiesModel} {
          ...OmitDefaults<OptionalProperties<UpdateableProperties<${armResourceInfo.propertiesType.name}>>>
        }`;
        // Only TrackedResources have a tags property
        const tagsString = armResourceInfo.resourceKind === "Tracked" ? "...ArmTagsProperty;" : "";
        evalInNamespace(program, armResourceInfo.parentNamespace, `${propertiesModelString}
       @doc("The updatable properties of the ${armResourceInfo.resourceModelName}.")
       model ${updateModelName} {
         ${tagsString}
         ...${updatePropertiesModel};
       }`);
    }
    evalInNamespace(program, namespace, `@doc("${documentation}")
     @patch op Update(${getOperationPathArguments(operationParams)}, @doc("The resource properties to be updated.") @body resource: ${updateModelName}): ArmResponse<${armResourceInfo.resourceModelName}> | ErrorResponse;`);
}
export function armStandardDelete(program, target, documentation) {
    var _a;
    const info = prepareOperationInfo(program, "armStandardDelete", target);
    if (!info) {
        return;
    }
    const { armResourceInfo, operationParams, namespace } = info;
    (_a = armResourceInfo.operationNamespaces) === null || _a === void 0 ? void 0 : _a.add(namespace);
    if (!documentation) {
        documentation = `Delete a ${armResourceInfo.resourceModelName}`;
    }
    const lroFinalState = "azure-async-operation";
    evalInNamespace(program, namespace, `@doc("${documentation}")
       @extension("x-ms-long-running-operation", true)
       @asyncOperationOptions("${lroFinalState}")
       @delete op Delete(${getOperationPathArguments(operationParams)}): ArmDeletedResponse | ArmDeletedNoContentResponse | ArmDeleteAcceptedResponse | ErrorResponse;`);
}
export function armStandardList(program, target, documentation) {
    const info = prepareOperationInfo(program, "armStandardList", target);
    if (!info) {
        return;
    }
    const { armResourceInfo, operationParams, namespace } = info;
    if (armResourceInfo.resourceKind === "Tracked") {
        armListByInternal(program, target, armResourceInfo, "SubscriptionIdParameter", "ListBySubscription", `List ${armResourceInfo.resourceModelName} resources by subscription ID`);
        armListByInternal(program, target, armResourceInfo, "ResourceGroupNameParameter", "ListByResourceGroup", `List ${armResourceInfo.resourceModelName} resources by resource group`);
    }
}
export function generateStandardOperations(program, resourceType, standardOperations) {
    for (const op of standardOperations) {
        const generator = standardOperationFunctions[op];
        if (generator) {
            generator(program, resourceType);
        }
        else {
            reportDiagnostic(program, {
                code: "unknown-std-operation",
                target: resourceType,
                format: { operation: op },
            });
        }
    }
}
function armListByInternal(program, target, armResourceInfo, paramTypeName, operationName, documentation) {
    var _a;
    const resourcePath = armResourceInfo.resourcePath;
    if (!resourcePath) {
        reportDiagnostic(program, {
            code: "list-operation-with-resource-path",
            target,
        });
        return;
    }
    // There are two cases here:
    // 1. Parameter comes before the resource type in the path
    // 2. Parameter is the parameter type for this resource
    //
    // In the second case, we interpret this as "list all resources of this type
    // for the provider"
    let pathParams = resourcePath.parameters;
    const paramInfo = armResourceInfo.resourceNameParam &&
        armResourceInfo.resourceNameParam.typeName === paramTypeName
        ? armResourceInfo.resourceNameParam
        : pathParams.find((p) => p.typeName === paramTypeName);
    if (!paramInfo) {
        reportDiagnostic(program, {
            code: "parameter-in-resource",
            target,
        });
        return;
    }
    let basePath = "";
    const pathParts = resourcePath.path.split("/");
    if (paramInfo !== armResourceInfo.resourceNameParam) {
        if (!documentation) {
            documentation = `List all ${armResourceInfo.resourceModelName} by ${paramInfo.name}`;
        }
        // Remove the later parameters
        const paramIndex = pathParams.findIndex((p) => p.typeName === paramTypeName) + 1;
        pathParams = pathParams.slice(0, paramIndex);
        // Generate the base path
        const pathParam = `{${paramInfo.name}}`;
        basePath = resourcePath.path.substring(0, resourcePath.path.indexOf(pathParam) + pathParam.length);
    }
    else {
        pathParams = [];
        documentation = `List all ${armResourceInfo.resourceModelName} resources for the ${armResourceInfo.armNamespace} provider`;
    }
    // Insert the provider name again?
    if (basePath.indexOf(armResourceInfo.armNamespace) < 0) {
        basePath = `${basePath}/providers/${armResourceInfo.armNamespace}`;
    }
    const finalPath = basePath + "/" + pathParts[pathParts.length - 1];
    (_a = armResourceInfo.operationNamespaces) === null || _a === void 0 ? void 0 : _a.add(armResourceInfo.collectionName + "." + operationName);
    program.evalCadlScript(`
    using Azure.ARM;
    namespace ${armResourceInfo.parentNamespace} {
      @tag("${armResourceInfo.collectionName}")
      @resource("${finalPath}")
      namespace ${armResourceInfo.collectionName}${operationName} {
        @doc("${documentation}")
        @operationId("${armResourceInfo.collectionName}_${operationName}")
        @list @get op ${operationName}(${getOperationPathArguments(pathParams)}): ArmResponse<${armResourceInfo.resourceListModelName}> | ErrorResponse;
      }
    }`);
}
function checkOperationName(program, target, operationName, armResourceInfo) {
    if (operationName.includes(armResourceInfo.resourceModelName)) {
        reportDiagnostic(program, {
            code: "no-repeated-resource-in-operation",
            format: { resourceModelName: armResourceInfo.resourceModelName },
            target,
        });
    }
    if (operationName.includes("_")) {
        reportDiagnostic(program, {
            code: "no-underscore-in-operation-name",
            target,
        });
    }
}
export function $armListBy(program, target, paramType, operationName, documentation) {
    const armResourceInfo = getArmResourceInfo(program, target);
    if (!armResourceInfo) {
        return;
    }
    if (!armResourceInfo.resourcePath) {
        reportDiagnostic(program, {
            code: "decorator-with-resource-path",
            format: { decoratorName: "armListBy" },
            target,
        });
        return;
    }
    if (paramType.kind !== "Model") {
        reportDiagnostic(program, {
            code: "decorator-wrong-type",
            messageId: "armListBy",
            target,
        });
        return;
    }
    checkOperationName(program, target, operationName, armResourceInfo);
    armListByInternal(program, target, armResourceInfo, paramType.name, operationName, documentation);
}
//# sourceMappingURL=operations.js.map