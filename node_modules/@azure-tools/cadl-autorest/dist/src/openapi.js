import { getAllTags, getDoc, getFormat, getMaxLength, getMaxValue, getMinLength, getMinValue, getVisibility, isErrorType, isIntrinsic, isList, isNumericType, isSecret, isStringType, SyntaxKind, } from "@cadl-lang/compiler";
import { basePathForResource, checkIfServiceNamespace, getConsumes, getHeaderFieldName, getOperationRoute, getPathParamName, getProduces, getQueryParamName, getResources, getServiceHost, getServiceNamespaceString, getServiceTitle, getServiceVersion, isBody, isHeader, } from "@cadl-lang/rest";
import * as path from "path";
import { reportDiagnostic } from "./lib.js";
export async function $onBuild(p) {
    const options = {
        outputFile: p.compilerOptions.swaggerOutputFile || path.resolve("./openapi.json"),
    };
    const emitter = createOAPIEmitter(p, options);
    await emitter.emitOpenAPI();
}
const operationIdsKey = Symbol();
export function $operationId(program, entity, opId) {
    program.stateMap(operationIdsKey).set(entity, opId);
}
const pageableOperationsKey = Symbol();
export function $pageable(program, entity, nextLinkName = "nextLink") {
    program.stateMap(pageableOperationsKey).set(entity, nextLinkName);
}
function getPageable(program, entity) {
    return program.stateMap(pageableOperationsKey).get(entity);
}
const refTargetsKey = Symbol();
export function $useRef(program, entity, refUrl) {
    if (entity.kind === "Model" || entity.kind === "ModelProperty") {
        program.stateMap(refTargetsKey).set(entity, refUrl);
    }
    else {
        reportDiagnostic(program, {
            code: "decorator-wrong-type",
            messageId: "modelsOperations",
            format: { decoratorName: "useRef" },
            target: entity,
        });
    }
}
function getRef(program, entity) {
    return program.stateMap(refTargetsKey).get(entity);
}
// NOTE: These functions aren't meant to be used directly as decorators but as a
// helper functions for other decorators.  The security information given here
// will be inserted into the `security` and `securityDefinitions` sections of
// the emitted OpenAPI document.
const securityDetailsKey = Symbol();
const securityRequirementsKey = "requirements";
const securityDefinitionsKey = "definitions";
function getSecurityRequirements(program) {
    const definitions = program.stateMap(securityDetailsKey);
    return (definitions === null || definitions === void 0 ? void 0 : definitions.has(securityRequirementsKey)) ? definitions.get(securityRequirementsKey) : [];
}
function setSecurityRequirements(program, requirements) {
    program.stateMap(securityDetailsKey).set(securityRequirementsKey, requirements);
}
function getSecurityDefinitions(program) {
    const definitions = program.stateMap(securityDetailsKey);
    return (definitions === null || definitions === void 0 ? void 0 : definitions.has(securityDefinitionsKey)) ? definitions.get(securityDefinitionsKey) : {};
}
function setSecurityDefinitions(program, definitions) {
    program.stateMap(securityDetailsKey).set(securityDefinitionsKey, definitions);
}
export function addSecurityRequirement(program, namespace, name, scopes) {
    if (!checkIfServiceNamespace(program, namespace)) {
        reportDiagnostic(program, {
            code: "security-service-namespace",
            target: namespace,
        });
    }
    const req = {};
    req[name] = scopes;
    const requirements = getSecurityRequirements(program);
    requirements.push(req);
    setSecurityRequirements(program, requirements);
}
export function addSecurityDefinition(program, namespace, name, details) {
    if (!checkIfServiceNamespace(program, namespace)) {
        reportDiagnostic(program, {
            code: "security-service-namespace",
            target: namespace,
        });
        return;
    }
    const definitions = getSecurityDefinitions(program);
    definitions[name] = details;
    setSecurityDefinitions(program, definitions);
}
const openApiExtensions = new Map();
export function $extension(program, entity, extensionName, value) {
    var _a;
    let typeExtensions = (_a = openApiExtensions.get(entity)) !== null && _a !== void 0 ? _a : new Map();
    typeExtensions.set(extensionName, value);
    openApiExtensions.set(entity, typeExtensions);
}
export function $asyncOperationOptions(program, entity, finalStateVia) {
    var _a;
    let typeExtensions = (_a = openApiExtensions.get(entity)) !== null && _a !== void 0 ? _a : new Map();
    typeExtensions.set("x-ms-long-running-operation-options", { "final-state-via": finalStateVia });
    openApiExtensions.set(entity, typeExtensions);
}
function getExtensions(entity) {
    var _a;
    return (_a = openApiExtensions.get(entity)) !== null && _a !== void 0 ? _a : new Map();
}
function createOAPIEmitter(program, options) {
    const root = {
        swagger: "2.0",
        info: {
            title: getServiceTitle(program),
            version: getServiceVersion(program),
        },
        host: getServiceHost(program),
        schemes: ["https"],
        produces: [],
        consumes: [],
        security: getSecurityRequirements(program),
        securityDefinitions: getSecurityDefinitions(program),
        tags: [],
        paths: {},
        "x-ms-paths": {},
        definitions: {},
        parameters: {},
    };
    // Get the service namespace string for use in name shortening
    const serviceNamespace = getServiceNamespaceString(program);
    let currentBasePath = "";
    let currentPath = root.paths;
    let currentEndpoint;
    // Keep a list of all Types encountered that need schema definitions
    const schemas = new Set();
    // Map model properties that represent shared parameters to their parameter
    // definition that will go in #/parameters. Inlined parameters do not go in
    // this map.
    const params = new Map();
    // De-dupe the per-endpoint tags that will be added into the #/tags
    const tags = new Set();
    // The set of produces/consumes values found in all operations
    const globalProduces = new Set();
    const globalConsumes = new Set();
    return { emitOpenAPI };
    async function emitOpenAPI() {
        try {
            for (let resource of getResources(program)) {
                if (resource.kind !== "Namespace") {
                    reportDiagnostic(program, {
                        code: "resource-namespace",
                        target: resource,
                    });
                    continue;
                }
                emitResource(resource);
            }
            emitReferences();
            emitTags();
            // Finalize global produces/consumes
            if (globalProduces.size > 0) {
                root.produces = [...globalProduces.values()];
            }
            else {
                delete root.produces;
            }
            if (globalConsumes.size > 0) {
                root.consumes = [...globalConsumes.values()];
            }
            else {
                delete root.consumes;
            }
            // Clean up empty entries
            if (Object.keys(root["x-ms-paths"]).length === 0) {
                delete root["x-ms-paths"];
            }
            if (Object.keys(root.security).length === 0) {
                delete root["security"];
            }
            if (Object.keys(root.securityDefinitions).length === 0) {
                delete root["securityDefinitions"];
            }
            if (!program.compilerOptions.noEmit && !program.hasError()) {
                // Sort the document
                const sortedRoot = sortOpenAPIDocument(root);
                // Write out the OpenAPI document to the output path
                await program.host.writeFile(path.resolve(options.outputFile), prettierOutput(JSON.stringify(sortedRoot, null, 2)));
            }
        }
        catch (err) {
            if (err instanceof ErrorTypeFoundError) {
                // Return early, there must be a parse error if an ErrorType was
                // inserted into the Cadl output
                return;
            }
            else {
                throw err;
            }
        }
    }
    function emitResource(resource) {
        currentBasePath = basePathForResource(program, resource);
        // Gather produces/consumes data up the namespace hierarchy
        let currentNamespace = resource;
        while (currentNamespace) {
            getProduces(program, currentNamespace).forEach((p) => globalProduces.add(p));
            getConsumes(program, currentNamespace).forEach((c) => globalConsumes.add(c));
            currentNamespace = currentNamespace.namespace;
        }
        for (const [name, op] of resource.operations) {
            emitEndpoint(resource, op);
        }
    }
    function getPathParameters(ns, op) {
        var _a, _b;
        return [...((_b = (_a = op.parameters) === null || _a === void 0 ? void 0 : _a.properties.values()) !== null && _b !== void 0 ? _b : [])].filter((param) => getPathParamName(program, param) !== undefined);
    }
    /**
     * Translates endpoint names like `read` to REST verbs like `get`.
     */
    function pathForEndpoint(op, pathParams) {
        var _a, _b, _c;
        const paramByName = new Map(pathParams.map((p) => [p.name, p]));
        const route = getOperationRoute(program, op);
        const inferredVerb = verbForEndpoint(op.name);
        const verb = (route === null || route === void 0 ? void 0 : route.verb) || inferredVerb || "get";
        // Build the full route path including any sub-path
        const routePath = (currentBasePath || "") +
            ((route === null || route === void 0 ? void 0 : route.subPath)
                ? `/${(_a = route === null || route === void 0 ? void 0 : route.subPath) === null || _a === void 0 ? void 0 : _a.replace(/^\//g, "")}`
                : !inferredVerb && !route
                    ? "/get"
                    : "");
        // Find path parameter names
        const declaredPathParamNames = (_c = (_b = routePath.match(/\{\w+\}/g)) === null || _b === void 0 ? void 0 : _b.map((s) => s.slice(1, -1))) !== null && _c !== void 0 ? _c : [];
        // For each param in the declared path parameters (e.g. /foo/{id} has one, id),
        // delete it because it doesn't need to be added to the path.
        for (const declaredParam of declaredPathParamNames) {
            const param = paramByName.get(declaredParam);
            if (!param) {
                reportDiagnostic(program, {
                    code: "missing-path-param",
                    format: { param: declaredParam },
                    target: op,
                });
                continue;
            }
            paramByName.delete(declaredParam);
        }
        // Add any remaining declared path params
        const pathSegments = [];
        for (const name of paramByName.keys()) {
            pathSegments.push(name);
        }
        return [verb, pathSegments, routePath];
    }
    function verbForEndpoint(name) {
        switch (name) {
            case "list":
                return "get";
            case "create":
                return "post";
            case "read":
                return "get";
            case "update":
                return "get";
            case "delete":
                return "delete";
            case "deleteAll":
                return "delete";
        }
        return undefined;
    }
    function addProduces(producesValue) {
        if (globalProduces.size < 1) {
            globalProduces.add(producesValue);
        }
        if (!globalProduces.has(producesValue)) {
            if (!currentEndpoint.produces) {
                currentEndpoint.produces = [];
            }
            if (!currentEndpoint.produces.includes(producesValue)) {
                currentEndpoint.produces.push(producesValue);
            }
        }
    }
    function addConsumes(consumesValue) {
        if (globalConsumes.size < 1) {
            globalConsumes.add(consumesValue);
        }
        if (!globalConsumes.has(consumesValue)) {
            if (!currentEndpoint.consumes) {
                currentEndpoint.consumes = [];
            }
            if (!currentEndpoint.consumes.includes(consumesValue)) {
                currentEndpoint.consumes.push(consumesValue);
            }
        }
    }
    function emitEndpoint(resource, op) {
        var _a, _b;
        const params = getPathParameters(resource, op);
        const [verb, newPathParams, resolvedPath] = pathForEndpoint(op, params);
        const fullPath = resolvedPath +
            (newPathParams.length > 0 ? "/" + newPathParams.map((p) => "{" + p + "}").join("/") : "");
        // If path contains a literal query string parameter, add it to x-ms-paths instead
        let pathsObject = fullPath.indexOf("?") < 0 ? root.paths : root["x-ms-paths"];
        if (!pathsObject[fullPath]) {
            pathsObject[fullPath] = {};
        }
        currentPath = pathsObject[fullPath];
        if (!currentPath[verb]) {
            currentPath[verb] = {};
        }
        currentEndpoint = currentPath[verb];
        if (program.stateMap(operationIdsKey).has(op)) {
            currentEndpoint.operationId = program.stateMap(operationIdsKey).get(op);
        }
        else {
            // Synthesize an operation ID
            currentEndpoint.operationId = `${resource.name}_${op.name}`;
        }
        // allow operation extensions
        attachExtensions(op, currentEndpoint);
        currentEndpoint.summary = getDoc(program, op);
        currentEndpoint.parameters = [];
        currentEndpoint.responses = {};
        const currentTags = getAllTags(program, resource, op);
        if (currentTags) {
            currentEndpoint.tags = currentTags;
            for (const tag of currentTags) {
                // Add to root tags if not already there
                tags.add(tag);
            }
        }
        if (isList(program, op) || getPageable(program, op)) {
            const nextLinkName = getPageable(program, op) || "nextLink";
            if (nextLinkName) {
                currentEndpoint["x-ms-pageable"] = {
                    nextLinkName,
                };
            }
        }
        emitEndpointParameters(op, op.parameters, [...((_b = (_a = op.parameters) === null || _a === void 0 ? void 0 : _a.properties.values()) !== null && _b !== void 0 ? _b : [])]);
        emitResponses(op.returnType);
    }
    function emitResponses(responseType) {
        if (responseType.kind === "Union") {
            for (const [i, option] of responseType.options.entries()) {
                emitResponseObject(option, i === 0 ? "200" : "default");
            }
        }
        else {
            emitResponseObject(responseType);
        }
    }
    function emitResponseObject(responseModel, statusCode = "200") {
        var _a;
        if (responseModel.kind === "Model" &&
            !responseModel.baseModel &&
            responseModel.properties.size === 0) {
            currentEndpoint.responses[200] = {
                description: "Null response",
            };
            return;
        }
        let contentType = "application/json";
        const response = {};
        let bodyModel = responseModel;
        if (responseModel.kind === "Model") {
            for (const prop of responseModel.properties.values()) {
                if (isBody(program, prop)) {
                    if (bodyModel !== responseModel) {
                        reportDiagnostic(program, { code: "duplicate-body", target: responseModel });
                        continue;
                    }
                    bodyModel = prop.type;
                }
                const type = prop.type;
                const headerName = getHeaderFieldName(program, prop);
                switch (headerName) {
                    case undefined:
                        break;
                    case "status-code":
                        if (type.kind === "Number") {
                            statusCode = String(type.value);
                        }
                        break;
                    case "content-type":
                        if (type.kind === "String") {
                            contentType = type.value;
                        }
                        break;
                    default:
                        const header = getResponseHeader(prop);
                        response.headers = (_a = response.headers) !== null && _a !== void 0 ? _a : {};
                        response.headers[headerName] = header;
                        break;
                }
            }
        }
        response.description = getResponseDescription(responseModel, statusCode);
        if (!isEmptyResponse(bodyModel)) {
            let responseSchema = getSchemaOrRef(bodyModel);
            response.schema = responseSchema;
        }
        addProduces(contentType);
        currentEndpoint.responses[statusCode] = response;
    }
    function isEmptyResponse(adlType) {
        switch (adlType.kind) {
            case "TemplateParameter":
                {
                    if (adlType.instantiationParameters) {
                        for (let element of adlType.instantiationParameters) {
                            if (!isEmptyResponse(element))
                                return false;
                        }
                    }
                }
                return true;
            case "Model": {
                if (isIntrinsic(program, adlType)) {
                    return false;
                }
                if (adlType.properties) {
                    for (let element of adlType.properties.values()) {
                        if (!isHeader(program, element))
                            return false;
                    }
                }
                if (adlType.baseModel) {
                    if (!isEmptyResponse(adlType.baseModel))
                        return false;
                }
                if (adlType.templateArguments) {
                    for (let element of adlType.templateArguments) {
                        if (!isEmptyResponse(element))
                            return false;
                    }
                }
                return true;
            }
            case "Tuple":
                for (let element of adlType.values) {
                    if (!isEmptyResponse(element))
                        return false;
                }
                return false;
            case "Union":
                for (let element of adlType.options) {
                    if (!isEmptyResponse(element))
                        return false;
                }
                return false;
            default:
                return false;
        }
    }
    function getResponseDescription(responseModel, statusCode) {
        const desc = getDoc(program, responseModel);
        if (desc) {
            return desc;
        }
        if (statusCode === "default") {
            return "An unexpected error response";
        }
        return "A successful response";
    }
    function getResponseHeader(prop) {
        const header = {};
        populateParameter(header, prop, undefined);
        delete header.in;
        delete header.name;
        delete header.required;
        return header;
    }
    function getSchemaOrRef(type) {
        const refUrl = getRef(program, type);
        if (refUrl) {
            return {
                $ref: refUrl,
            };
        }
        if (type.kind === "Model" && !type.baseModel) {
            // If this is a model that isn't derived from anything, there's a chance
            // it's a base Cadl "primitive" that corresponds directly to an OpenAPI
            // primitive. In such cases, we don't want to emit a ref and instead just
            // emit the base type directly.
            const builtIn = mapCadlTypeToOpenAPI(type);
            if (builtIn !== undefined) {
                return builtIn;
            }
        }
        if (type.kind === "String" || type.kind === "Number" || type.kind === "Boolean") {
            // For literal types, we just want to emit them directly as well.
            return mapCadlTypeToOpenAPI(type);
        }
        const name = getTypeNameForSchemaProperties(type);
        if (!isRefSafeName(name)) {
            // Schema's name is not reference-able in OpenAPI so we inline it.
            // This will usually happen with instantiated/anonymous types, but could also
            // happen if Cadl identifier uses characters that are problematic for OpenAPI.
            // Users will have to rename / alias type to have it get ref'ed.
            const schema = getSchemaForType(type);
            if (schema === undefined && isErrorType(type)) {
                // Exit early so that syntax errors are exposed.  This error will
                // be caught and handled in emitOpenAPI.
                throw new ErrorTypeFoundError();
            }
            // helps to read output and correlate to Cadl
            if (schema) {
                schema["x-cadl-name"] = name;
            }
            return schema;
        }
        else {
            const placeholder = {
                $ref: "#/definitions/" + name,
            };
            schemas.add(type);
            return placeholder;
        }
    }
    function getParamPlaceholder(parent, property) {
        let spreadParam = false;
        if (property.sourceProperty) {
            // chase our sources all the way back to the first place this property
            // was defined.
            spreadParam = true;
            property = property.sourceProperty;
            while (property.sourceProperty) {
                property = property.sourceProperty;
            }
        }
        const refUrl = getRef(program, property);
        if (refUrl) {
            return {
                $ref: refUrl,
            };
        }
        if (params.has(property)) {
            return params.get(property);
        }
        const placeholder = {};
        // only parameters inherited by spreading or from interface are shared in #/parameters
        // bt: not sure about the interface part of this comment?
        if (spreadParam) {
            params.set(property, placeholder);
        }
        return placeholder;
    }
    function emitEndpointParameters(op, parent, methodParams) {
        const parameters = [...methodParams];
        let bodyType;
        let emittedImplicitBodyParam = false;
        for (const param of parameters) {
            if (params.has(param)) {
                currentEndpoint.parameters.push(params.get(param));
                continue;
            }
            const queryInfo = getQueryParamName(program, param);
            const pathInfo = getPathParamName(program, param);
            const headerInfo = getHeaderFieldName(program, param);
            const bodyInfo = isBody(program, param);
            if (pathInfo) {
                emitParameter(parent, param, "path");
            }
            else if (queryInfo) {
                emitParameter(parent, param, "query");
            }
            else if (headerInfo) {
                if (headerInfo === "content-type") {
                    getContentTypes(param).forEach((c) => addConsumes(c));
                }
                else {
                    emitParameter(parent, param, "header");
                }
            }
            else if (bodyInfo) {
                bodyType = param.type;
                emitParameter(parent, param, "body");
            }
            else {
                if (emittedImplicitBodyParam) {
                    reportDiagnostic(program, { code: "duplicate-body-types", target: op });
                    continue;
                }
                emittedImplicitBodyParam = true;
                bodyType = param.type;
                emitParameter(parent, param, "body");
            }
        }
        if ((!currentEndpoint.consumes || currentEndpoint.consumes.length === 0) && bodyType) {
            // we didn't find an explicit content type anywhere, so infer from body.
            const modelType = getModelTypeIfNullable(bodyType);
            if (modelType) {
                let contentTypeParam = modelType.properties.get("contentType");
                if (contentTypeParam) {
                    getContentTypes(contentTypeParam).forEach((c) => addConsumes(c));
                }
                else {
                    addConsumes("application/json");
                }
            }
        }
    }
    function getContentTypes(param) {
        if (param.type.kind === "String") {
            return [param.type.value];
        }
        else if (param.type.kind === "Union") {
            const contentTypes = [];
            for (const option of param.type.options) {
                if (option.kind === "String") {
                    contentTypes.push(option.value);
                }
                else {
                    reportDiagnostic(program, {
                        code: "content-type-string",
                        messageId: "unionOfString",
                        target: param,
                    });
                    continue;
                }
            }
            return contentTypes;
        }
        reportDiagnostic(program, { code: "content-type-string", target: param });
        return [];
    }
    function getModelTypeIfNullable(type) {
        if (type.kind === "Model") {
            return type;
        }
        else if (type.kind === "Union") {
            // Remove all `null` types and make sure there's a single model type
            const nonNulls = type.options.filter((o) => !isNullType(o));
            if (nonNulls.every((t) => t.kind === "Model")) {
                return nonNulls.length === 1 ? nonNulls[0] : undefined;
            }
        }
        return undefined;
    }
    function emitParameter(parent, param, kind) {
        const ph = getParamPlaceholder(parent, param);
        currentEndpoint.parameters.push(ph);
        // If the parameter already has a $ref, don't bother populating it
        if (!("$ref" in ph)) {
            populateParameter(ph, param, kind);
        }
    }
    function populateParameter(ph, param, kind) {
        ph.name = param.name;
        ph.in = kind;
        ph.required = !param.optional;
        ph.description = getDoc(program, param);
        if (param.default) {
            ph.default = getDefaultValue(param.default);
        }
        // Apply decorators to a copy of the parameter definition.  We use
        // Object.assign here because applyIntrinsicDecorators returns a new object
        // based on the target object and we need to apply its changes back to the
        // original parameter.
        Object.assign(ph, applyIntrinsicDecorators(param, ph));
        let schema = getSchemaOrRef(param.type);
        if (kind === "body") {
            ph.schema = schema;
        }
        else {
            schema = getSchemaForType(param.type);
            if (param.type.kind === "Array") {
                schema.items = getSchemaForType(param.type.elementType);
            }
            for (const property in schema) {
                ph[property] = schema[property];
            }
        }
    }
    function emitReferences() {
        for (const [property, param] of params) {
            const key = getParameterKey(property, param);
            root.parameters[key] = {
                // Add an extension which tells AutoRest that this is a shared operation
                // parameter definition
                "x-ms-parameter-location": "method",
                ...param,
            };
            for (const key of Object.keys(param)) {
                delete param[key];
            }
            param["$ref"] = "#/parameters/" + key;
        }
        for (const type of schemas) {
            const name = getTypeNameForSchemaProperties(type);
            const schemaForType = getSchemaForType(type);
            if (schemaForType) {
                root.definitions[name] = schemaForType;
            }
        }
    }
    function emitTags() {
        for (const tag of tags) {
            root.tags.push({ name: tag });
        }
    }
    function getParameterKey(property, param) {
        const parent = program.checker.getTypeForNode(property.node.parent);
        let key = program.checker.getTypeName(parent);
        if (parent.properties.size > 1) {
            key += `.${property.name}`;
        }
        // Try to shorten the type name to exclude the top-level service namespace
        let baseKey = getRefSafeName(key);
        if (serviceNamespace && key.startsWith(serviceNamespace)) {
            baseKey = key.substring(serviceNamespace.length + 1);
            // If no parameter exists with the shortened name, use it, otherwise use the fully-qualified name
            if (root.parameters[baseKey] === undefined) {
                key = baseKey;
            }
        }
        return key;
    }
    function getSchemaForType(type) {
        const builtinType = mapCadlTypeToOpenAPI(type);
        if (builtinType !== undefined) {
            // add in description elements for types derived from primitive types (SecureString, etc.)
            const doc = getDoc(program, type);
            if (doc) {
                builtinType.description = doc;
            }
            return builtinType;
        }
        if (type.kind === "Array") {
            return getSchemaForArray(type);
        }
        else if (type.kind === "Model") {
            return getSchemaForModel(type);
        }
        else if (type.kind === "Union") {
            return getSchemaForUnion(type);
        }
        else if (type.kind === "Enum") {
            return getSchemaForEnum(type);
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.kind },
            target: type,
        });
        return undefined;
    }
    function getSchemaForEnum(e) {
        const values = [];
        const type = enumMemberType(e.members[0]);
        for (const option of e.members) {
            if (type !== enumMemberType(option)) {
                reportInvalidUnionForOpenAPIV2();
                continue;
            }
            values.push(option.value ? option.value : option.name);
        }
        const schema = { type, description: getDoc(program, e) };
        if (values.length > 0) {
            schema.enum = values;
            addXMSEnum(e, schema);
        }
        return schema;
        function enumMemberType(member) {
            if (!member.value || typeof member.value === "string")
                return "string";
            return "number";
        }
        function reportInvalidUnionForOpenAPIV2() {
            reportDiagnostic(program, { code: "union-unsupported", target: e });
        }
    }
    function getSchemaForUnion(union) {
        let type;
        const nonNullOptions = union.options.filter((t) => !isNullType(t));
        const nullable = union.options.length != nonNullOptions.length;
        if (nonNullOptions.length === 0) {
            reportDiagnostic(program, { code: "union-null", target: union });
            return {};
        }
        const kind = nonNullOptions[0].kind;
        switch (kind) {
            case "String":
                type = "string";
                break;
            case "Number":
                type = "number";
                break;
            case "Boolean":
                type = "boolean";
                break;
            case "Model":
                type = "model";
                break;
            default:
                reportInvalidUnionForOpenAPIV2();
                return {};
        }
        const values = [];
        if (type === "model") {
            // Model unions can only ever be a model type with 'null'
            if (nonNullOptions.length === 1) {
                // Get the schema for the model type
                const schema = getSchemaForType(nonNullOptions[0]);
                if (schema) {
                    schema["x-nullable"] = nullable;
                }
                return schema;
            }
            else {
                reportDiagnostic(program, {
                    code: "union-unsupported",
                    messageId: "null",
                    target: union,
                });
                return {};
            }
        }
        for (const option of nonNullOptions) {
            if (option.kind != kind) {
                reportInvalidUnionForOpenAPIV2();
            }
            // We already know it's not a model type
            values.push(option.value);
        }
        const schema = { type };
        if (values.length > 0) {
            schema.enum = values;
            addXMSEnum(union, schema);
        }
        if (nullable) {
            schema["x-nullable"] = true;
        }
        return schema;
        function reportInvalidUnionForOpenAPIV2() {
            reportDiagnostic(program, {
                code: "union-unsupported",
                target: union,
            });
        }
    }
    function getSchemaForArray(array) {
        const target = array.elementType;
        return {
            type: "array",
            items: getSchemaOrRef(target),
        };
    }
    function isNullType(type) {
        return type.kind === "Model" && type.name === "null" && isIntrinsic(program, type);
    }
    function getDefaultValue(type) {
        switch (type.kind) {
            case "String":
                return type.value;
            case "Number":
                return type.value;
            case "Boolean":
                return type.value;
            case "Tuple":
                return type.values.map(getDefaultValue);
            default:
                reportDiagnostic(program, {
                    code: "invalid-default",
                    format: { type: type.kind },
                    target: type,
                });
        }
    }
    function getSchemaForModel(model) {
        let modelSchema = {
            type: "object",
            properties: {},
            description: getDoc(program, model),
        };
        for (const [name, prop] of model.properties) {
            if (!isSchemaProperty(prop)) {
                continue;
            }
            const description = getDoc(program, prop);
            if (!prop.optional) {
                if (!modelSchema.required) {
                    modelSchema.required = [];
                }
                modelSchema.required.push(name);
            }
            // Apply decorators on the property to the type's schema
            modelSchema.properties[name] = applyIntrinsicDecorators(prop, getSchemaOrRef(prop.type));
            if (description) {
                modelSchema.properties[name].description = description;
            }
            if (prop.default) {
                modelSchema.properties[name].default = getDefaultValue(prop.default);
            }
            // Should the property be marked as readOnly?
            const vis = getVisibility(program, prop);
            if (vis && vis.includes("read")) {
                const mutability = [];
                if (vis.includes("read")) {
                    if (vis.length > 1) {
                        mutability.push("read");
                    }
                    else {
                        modelSchema.properties[name].readOnly = true;
                    }
                }
                if (vis.includes("write")) {
                    mutability.push("update");
                }
                if (vis.includes("create")) {
                    mutability.push("create");
                }
                if (mutability.length > 0) {
                    modelSchema.properties[name]["x-ms-mutability"] = mutability;
                }
            }
            // Attach any additional OpenAPI extensions
            attachExtensions(prop, modelSchema.properties[name]);
        }
        // Special case: if a model type extends a single *templated* base type and
        // has no properties of its own, absorb the definition of the base model
        // into this schema definition.  The assumption here is that any model type
        // defined like this is just meant to rename the underlying instance of a
        // templated type.
        if (model.baseModel &&
            model.baseModel.templateArguments &&
            model.baseModel.templateArguments.length > 0 &&
            Object.keys(modelSchema.properties).length === 0) {
            // Take the base model schema but carry across the documentation property
            // that we set before
            const baseSchema = getSchemaForType(model.baseModel);
            modelSchema = {
                ...baseSchema,
                description: modelSchema.description,
            };
        }
        else if (model.baseModel) {
            modelSchema.allOf = [getSchemaOrRef(model.baseModel)];
        }
        // Attach any OpenAPI extensions
        attachExtensions(model, modelSchema);
        return modelSchema;
    }
    function attachExtensions(type, emitObject) {
        // Attach any OpenAPI extensions
        const extensions = getExtensions(type);
        if (extensions) {
            for (const key of extensions.keys()) {
                emitObject[key] = extensions.get(key);
            }
        }
    }
    /**
     * A "schema property" here is a property that is emitted to OpenAPI schema.
     *
     * Headers, parameters, status codes are not schema properties even they are
     * represented as properties in Cadl.
     */
    function isSchemaProperty(property) {
        const headerInfo = getHeaderFieldName(program, property);
        const queryInfo = getQueryParamName(program, property);
        const pathInfo = getPathParamName(program, property);
        return !(headerInfo || queryInfo || pathInfo);
    }
    function getTypeNameForSchemaProperties(type) {
        // Try to shorten the type name to exclude the top-level service namespace
        let typeName = program.checker.getTypeName(type).replace(/<([\w\.]+)>/, "_$1");
        if (isRefSafeName(typeName)) {
            if (serviceNamespace) {
                typeName = typeName.replace(RegExp(serviceNamespace + "\\.", "g"), "");
            }
            // exclude the Cadl namespace in type names
            typeName = typeName.replace(/($|_)(Cadl\.)/g, "$1");
        }
        return typeName;
    }
    function hasSchemaProperties(properties) {
        for (const property of properties.values()) {
            if (isSchemaProperty(property)) {
                return true;
            }
        }
        return false;
    }
    function applyIntrinsicDecorators(cadlType, target) {
        const pattern = getFormat(program, cadlType);
        if (isStringType(program, cadlType) && !target.pattern && pattern) {
            target = {
                ...target,
                pattern,
            };
        }
        const minLength = getMinLength(program, cadlType);
        if (isStringType(program, cadlType) && !target.minLength && minLength !== undefined) {
            target = {
                ...target,
                minLength,
            };
        }
        const maxLength = getMaxLength(program, cadlType);
        if (isStringType(program, cadlType) && !target.maxLength && maxLength !== undefined) {
            target = {
                ...target,
                maxLength,
            };
        }
        const minValue = getMinValue(program, cadlType);
        if (isNumericType(program, cadlType) && !target.minimum && minValue !== undefined) {
            target = {
                ...target,
                minimum: minValue,
            };
        }
        const maxValue = getMaxValue(program, cadlType);
        if (isNumericType(program, cadlType) && !target.maximum && maxValue !== undefined) {
            target = {
                ...target,
                maximum: maxValue,
            };
        }
        if (isSecret(program, cadlType)) {
            target = {
                ...target,
                format: "password",
                "x-ms-secret": true,
            };
        }
        return target;
    }
    function addXMSEnum(type, schema) {
        // For now, automatically treat any nominal union type as an `x-ms-enum`
        // that is expandable, i.e. sets `modelAsString: true`
        if (type.node.parent && type.node.parent.kind === SyntaxKind.ModelStatement) {
            schema["x-ms-enum"] = {
                name: type.node.parent.id.sv,
                modelAsString: true,
            };
        }
        else if (type.kind === "Enum") {
            schema["x-ms-enum"] = {
                name: type.name,
                modelAsString: true,
            };
        }
        return schema;
    }
    // Map an Cadl type to an OA schema. Returns undefined when the resulting
    // OA schema is just a regular object schema.
    function mapCadlTypeToOpenAPI(cadlType) {
        switch (cadlType.kind) {
            case "Number":
                return { type: "number", enum: [cadlType.value] };
            case "String":
                return addXMSEnum(cadlType, { type: "string", enum: [cadlType.value] });
            case "Boolean":
                return { type: "boolean", enum: [cadlType.value] };
            case "Model":
                switch (cadlType.name) {
                    case "bytes":
                        return { type: "string", format: "byte" };
                    case "int8":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "int8" });
                    case "int16":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "int16" });
                    case "int32":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "int32" });
                    case "int64":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "int64" });
                    case "uint8":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "uint8" });
                    case "uint16":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "uint16" });
                    case "uint32":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "uint32" });
                    case "uint64":
                        return applyIntrinsicDecorators(cadlType, { type: "integer", format: "uint64" });
                    case "float64":
                        return applyIntrinsicDecorators(cadlType, { type: "number", format: "double" });
                    case "float32":
                        return applyIntrinsicDecorators(cadlType, { type: "number", format: "float" });
                    case "string":
                        return applyIntrinsicDecorators(cadlType, { type: "string" });
                    case "boolean":
                        return { type: "boolean" };
                    case "plainDate":
                        return { type: "string", format: "date" };
                    case "zonedDateTime":
                        return { type: "string", format: "date-time" };
                    case "plainTime":
                        return { type: "string", format: "time" };
                    case "Map":
                        // We assert on valType because Map types always have a type
                        const valType = cadlType.properties.get("v");
                        return {
                            type: "object",
                            additionalProperties: getSchemaOrRef(valType.type),
                        };
                }
        }
        // The base model doesn't correspond to a primitive OA type, but it could
        // derive from one. Let's check.
        if (cadlType.kind === "Model" && cadlType.baseModel) {
            const baseSchema = mapCadlTypeToOpenAPI(cadlType.baseModel);
            if (baseSchema) {
                return applyIntrinsicDecorators(cadlType, baseSchema);
            }
        }
    }
}
function isRefSafeName(name) {
    return /^[A-Za-z0-9-_.]+$/.test(name);
}
function getRefSafeName(name) {
    return name.replace(/^[A-Za-z0-9-_.]/g, "_");
}
function prettierOutput(output) {
    return output + "\n";
}
class ErrorTypeFoundError extends Error {
    constructor() {
        super("Error type found in evaluated Cadl output");
    }
}
function sortObjectByKeys(obj, compareFn = undefined) {
    return Object.keys(obj)
        .sort(compareFn)
        .reduce((sortedObj, key) => {
        sortedObj[key] = obj[key];
        return sortedObj;
    }, {});
}
export function comparePaths(leftPath, rightPath) {
    const leftParts = leftPath.split("/").slice(1);
    const rightParts = rightPath.split("/").slice(1);
    for (let i = 0; i < Math.max(leftParts.length, rightParts.length); i++) {
        // Have we exhausted the path parts of one of them?
        if (i === leftParts.length)
            return -1;
        if (i === rightParts.length)
            return 1;
        // Does this segment represent a path parameter (field) on either side?
        const leftIsField = leftParts[i][0] === "{";
        const rightIsField = rightParts[i][0] === "{";
        // If both are fields, try the next part regardless of the field name
        // since the field ordering is all that really matters
        if (leftIsField && rightIsField) {
            continue;
        }
        // If only one is a field, it automatically wins
        if (leftIsField || rightIsField) {
            return leftIsField ? -1 : 1;
        }
        // Sort lexicographically
        const result = leftParts[i].localeCompare(rightParts[i]);
        if (result !== 0) {
            return result;
        }
    }
    // Must be the same
    return 0;
}
function sortOpenAPIDocument(doc) {
    doc.paths = sortObjectByKeys(doc.paths, comparePaths);
    doc.definitions = sortObjectByKeys(doc.definitions);
    doc.parameters = sortObjectByKeys(doc.parameters);
    return doc;
}
//# sourceMappingURL=openapi.js.map