import { readdir } from "fs/promises";
import Mustache from "mustache";
import { basename, join } from "path";
import prompts from "prompts";
import { logDiagnostics } from "../core/diagnostics.js";
import { formatCadl } from "../core/formatter.js";
import { SchemaValidator } from "../core/schema-validator.js";
import { readUrlOrPath, resolveRelativeUrlOrPath } from "../core/util.js";
import { InitTemplateDefinitionsSchema } from "./init-template.js";
export async function initCadlProject(host, directory, templatesUrl) {
    if (!(await confirmDirectoryEmpty(directory))) {
        return;
    }
    const folderName = basename(directory);
    const template = await selectTemplate(host, templatesUrl);
    const { name } = await prompts([
        {
            type: "text",
            name: "name",
            message: `Project name`,
            initial: folderName,
        },
    ]);
    const libraries = await selectLibraries(template);
    const parameters = await promptCustomParameters(template);
    const scaffoldingConfig = {
        ...template,
        templateUri: templatesUrl !== null && templatesUrl !== void 0 ? templatesUrl : ".",
        libraries,
        name,
        directory,
        parameters,
    };
    await scaffoldNewProject(host, scaffoldingConfig);
}
async function promptCustomParameters(template) {
    if (!template.inputs) {
        return {};
    }
    const promptList = [...Object.entries(template.inputs)].map(([name, input]) => {
        return {
            name,
            type: input.type,
            message: input.description,
            initial: input.initialValue,
        };
    });
    return await prompts(promptList);
}
async function isDirectoryEmpty(directory) {
    try {
        const files = await readdir(directory);
        return files.length === 0;
    }
    catch {
        return true;
    }
}
async function confirmDirectoryEmpty(directory) {
    if (await isDirectoryEmpty(directory)) {
        return true;
    }
    return confirm(`Folder '${directory}' is not empty. Are you sure you want to initialize a new project here?`);
}
const builtInTemplates = {
    empty: {
        title: "Empty project",
        description: "Create an empty project.",
        libraries: [],
    },
    rest: {
        title: "Generic Rest API",
        description: "Create a project representing a generic Rest API",
        libraries: ["@cadl-lang/rest", "@cadl-lang/openapi"],
    },
};
async function confirm(message) {
    const { confirm } = await prompts({
        name: "confirm",
        type: "confirm",
        message,
        initial: true,
    });
    return confirm;
}
async function downloadTemplates(host, templatesUrl) {
    const file = await readUrlOrPath(host, templatesUrl);
    const json = JSON.parse(file.text);
    validateTemplateDefinitions(host, json, file);
    return json;
}
async function selectTemplate(host, templatesUrl) {
    const templates = templatesUrl === undefined ? builtInTemplates : await downloadTemplates(host, templatesUrl);
    return promptTemplateSelection(templates);
}
async function promptTemplateSelection(templates) {
    const { templateName } = await prompts({
        type: "select",
        name: "templateName",
        message: "Please select a template",
        choices: Object.entries(templates).map(([id, template]) => {
            return { value: id, description: template.description, title: template.title };
        }),
    });
    const template = templates[templateName];
    if (!template) {
        throw new Error(`Unexpected error: Cannot find template ${templateName}`);
    }
    return template;
}
async function selectLibraries(template) {
    if (template.libraries.length === 0) {
        return [];
    }
    const libraryChoices = template.libraries.map((x) => ({ name: x, description: "" }));
    const { libraries } = await prompts({
        type: "multiselect",
        name: "libraries",
        message: "Update the libraries?",
        choices: libraryChoices.map((x) => {
            return {
                title: x.name,
                description: x.description,
                value: x.name,
                selected: true,
            };
        }),
        initial: template.libraries,
    });
    return libraries;
}
export async function scaffoldNewProject(host, config) {
    await writePackageJson(host, config);
    await writeMain(host, config);
    await writeFiles(host, config);
}
async function writePackageJson(host, config) {
    const dependencies = {};
    for (const library of config.libraries) {
        dependencies[library] = "latest";
    }
    const packageJson = {
        name: config.name,
        dependencies,
    };
    return host.writeFile(join(config.directory, "package.json"), JSON.stringify(packageJson, null, 2));
}
async function writeMain(host, config) {
    const dependencies = {};
    for (const library of config.libraries) {
        dependencies[library] = "latest";
    }
    const lines = [...config.libraries.map((x) => `import "${x}";`), ""];
    const content = lines.join("\n");
    return host.writeFile(join(config.directory, "main.cadl"), await formatCadl(content));
}
async function writeFiles(host, config) {
    if (!config.files) {
        return;
    }
    for (const file of config.files) {
        await writeFile(host, config, file);
    }
}
async function writeFile(host, config, file) {
    const template = await readUrlOrPath(host, resolveRelativeUrlOrPath(config.templateUri, file.path));
    const content = Mustache.render(template.text, config);
    return host.writeFile(join(config.directory, file.destination), content);
}
function validateTemplateDefinitions(host, templates, file) {
    const validator = new SchemaValidator(InitTemplateDefinitionsSchema);
    const diagnostics = validator.validate(templates, file);
    if (diagnostics.length > 0) {
        logDiagnostics(diagnostics, host.logSink);
        throw new Error("Template contained error.");
    }
}
//# sourceMappingURL=init.js.map