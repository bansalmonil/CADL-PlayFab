import { isAsciiIdentifierContinue, isAsciiIdentifierStart, isBinaryDigit, isDigit, isHexDigit, isIdentifierContinue, isLineBreak, isLowercaseAsciiLetter, isNonAsciiIdentifierCharacter, isNonAsciiWhiteSpaceSingleLine, isWhiteSpaceSingleLine, utf16CodeUnits, } from "./charcode.js";
import { createSourceFile } from "./diagnostics.js";
import { createDiagnostic } from "./messages.js";
// All conflict markers consist of the same character repeated seven times.  If it is
// a <<<<<<< or >>>>>>> marker then it is also followed by a space.
const mergeConflictMarkerLength = 7;
export var Token;
(function (Token) {
    Token[Token["None"] = 0] = "None";
    Token[Token["Invalid"] = 1] = "Invalid";
    Token[Token["EndOfFile"] = 2] = "EndOfFile";
    // Trivia
    Token[Token["SingleLineComment"] = 3] = "SingleLineComment";
    Token[Token["MultiLineComment"] = 4] = "MultiLineComment";
    Token[Token["NewLine"] = 5] = "NewLine";
    Token[Token["Whitespace"] = 6] = "Whitespace";
    // We detect and provide better error recovery when we encounter a git merge marker.  This
    // allows us to edit files with git-conflict markers in them in a much more pleasant manner.
    Token[Token["ConflictMarker"] = 7] = "ConflictMarker";
    // Literals
    Token[Token["NumericLiteral"] = 8] = "NumericLiteral";
    Token[Token["StringLiteral"] = 9] = "StringLiteral";
    // Punctuation
    Token[Token["OpenBrace"] = 10] = "OpenBrace";
    Token[Token["CloseBrace"] = 11] = "CloseBrace";
    Token[Token["OpenParen"] = 12] = "OpenParen";
    Token[Token["CloseParen"] = 13] = "CloseParen";
    Token[Token["OpenBracket"] = 14] = "OpenBracket";
    Token[Token["CloseBracket"] = 15] = "CloseBracket";
    Token[Token["Dot"] = 16] = "Dot";
    Token[Token["Elipsis"] = 17] = "Elipsis";
    Token[Token["Semicolon"] = 18] = "Semicolon";
    Token[Token["Comma"] = 19] = "Comma";
    Token[Token["LessThan"] = 20] = "LessThan";
    Token[Token["GreaterThan"] = 21] = "GreaterThan";
    Token[Token["Equals"] = 22] = "Equals";
    Token[Token["Ampersand"] = 23] = "Ampersand";
    Token[Token["Bar"] = 24] = "Bar";
    Token[Token["Question"] = 25] = "Question";
    Token[Token["Colon"] = 26] = "Colon";
    Token[Token["At"] = 27] = "At";
    Token[Token["Hash"] = 28] = "Hash";
    // Update MaxPunctuation if anything is added right above here
    // Identifiers
    Token[Token["Identifier"] = 29] = "Identifier";
    // Statement Keywords
    Token[Token["ImportKeyword"] = 30] = "ImportKeyword";
    Token[Token["ModelKeyword"] = 31] = "ModelKeyword";
    Token[Token["NamespaceKeyword"] = 32] = "NamespaceKeyword";
    Token[Token["UsingKeyword"] = 33] = "UsingKeyword";
    Token[Token["OpKeyword"] = 34] = "OpKeyword";
    Token[Token["EnumKeyword"] = 35] = "EnumKeyword";
    Token[Token["AliasKeyword"] = 36] = "AliasKeyword";
    Token[Token["IsKeyword"] = 37] = "IsKeyword";
    Token[Token["InterfaceKeyword"] = 38] = "InterfaceKeyword";
    Token[Token["UnionKeyword"] = 39] = "UnionKeyword";
    // Update MaxStatementKeyword if anything is added right above here
    // Other keywords
    Token[Token["ExtendsKeyword"] = 40] = "ExtendsKeyword";
    Token[Token["TrueKeyword"] = 41] = "TrueKeyword";
    Token[Token["FalseKeyword"] = 42] = "FalseKeyword";
    // Update MaxKeyword if anything is added right above here
})(Token || (Token = {}));
const MinKeyword = Token.ImportKeyword;
const MaxKeyword = Token.FalseKeyword;
const MinPunctuation = Token.OpenBrace;
const MaxPunctuation = Token.Hash;
const MinStatementKeyword = Token.ImportKeyword;
const MaxStatementKeyword = Token.UnionKeyword;
/** @internal */
export const TokenDisplay = [
    "none",
    "invalid",
    "end of file",
    "single-line comment",
    "multi-line comment",
    "newline",
    "whitespace",
    "conflict marker",
    "numeric literal",
    "string literal",
    "'{'",
    "'}'",
    "'('",
    "')'",
    "'['",
    "']'",
    "'.'",
    "'...'",
    "';'",
    "','",
    "'<'",
    "'>'",
    "'='",
    "'&'",
    "'|'",
    "'?'",
    "':'",
    "'@'",
    "'#'",
    "identifier",
    "'import'",
    "'model'",
    "'namespace'",
    "'using'",
    "'op'",
    "'enum'",
    "'alias'",
    "'is'",
    "'interface'",
    "'union'",
    "'extends'",
    "'true'",
    "'false'",
];
/** @internal */
export const Keywords = [
    ["import", Token.ImportKeyword],
    ["model", Token.ModelKeyword],
    ["namespace", Token.NamespaceKeyword],
    ["interface", Token.InterfaceKeyword],
    ["union", Token.UnionKeyword],
    ["using", Token.UsingKeyword],
    ["op", Token.OpKeyword],
    ["extends", Token.ExtendsKeyword],
    ["is", Token.IsKeyword],
    ["enum", Token.EnumKeyword],
    ["alias", Token.AliasKeyword],
    ["true", Token.TrueKeyword],
    ["false", Token.FalseKeyword],
];
const KeywordMap = new Map(Keywords.map((e) => [keywordKey(e[0]), e[1]]));
// Since keywords are short and all lowercase, we can pack the whole string into
// a single number by using 5 bits for each letter, and use that as the map key.
// This lets us lookup keywords without making temporary substrings.
function keywordKey(keyword) {
    let key = 0;
    for (let i = 0; i < keyword.length; i++) {
        key = (key << 5) | (keyword.charCodeAt(i) - 97 /* a */);
    }
    return key;
}
export function isLiteral(token) {
    return (token === Token.NumericLiteral ||
        token === Token.StringLiteral ||
        token === Token.TrueKeyword ||
        token === Token.FalseKeyword);
}
export function isTrivia(token) {
    return (token === Token.Whitespace ||
        token === Token.NewLine ||
        token === Token.SingleLineComment ||
        token === Token.MultiLineComment);
}
export function isComment(token) {
    return token === Token.SingleLineComment || token === Token.MultiLineComment;
}
export function isKeyword(token) {
    return token >= MinKeyword && token <= MaxKeyword;
}
export function isPunctuation(token) {
    return token >= MinPunctuation && token <= MaxPunctuation;
}
export function isStatementKeyword(token) {
    return token >= MinStatementKeyword && token <= MaxStatementKeyword;
}
export function createScanner(source, diagnosticHandler) {
    const file = typeof source === "string" ? createSourceFile(source, "<anonymous file>") : source;
    const input = file.text;
    let position = 0;
    let token = Token.None;
    let tokenPosition = -1;
    let tokenFlags = 0 /* None */;
    // Skip BOM
    if (input.charCodeAt(position) === 65279 /* ByteOrderMark */) {
        position++;
    }
    return {
        get position() {
            return position;
        },
        get token() {
            return token;
        },
        get tokenPosition() {
            return tokenPosition;
        },
        file,
        scan,
        eof,
        getTokenText,
        getTokenValue,
    };
    function eof() {
        return position >= input.length;
    }
    function getTokenText() {
        return input.substring(tokenPosition, position);
    }
    function getTokenValue() {
        switch (token) {
            case Token.StringLiteral:
                return getStringTokenValue();
            case Token.Identifier:
                return getIdentifierTokenValue();
            default:
                return getTokenText();
        }
    }
    function lookAhead(offset) {
        return input.charCodeAt(position + offset);
    }
    function scan() {
        tokenPosition = position;
        tokenFlags = 0 /* None */;
        if (!eof()) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 13 /* CarriageReturn */:
                    if (lookAhead(1) === 10 /* LineFeed */) {
                        position++;
                    }
                // fallthrough
                case 10 /* LineFeed */:
                    return next(Token.NewLine);
                case 32 /* Space */:
                case 9 /* Tab */:
                case 11 /* VerticalTab */:
                case 12 /* FormFeed */:
                    return scanWhitespace();
                case 40 /* OpenParen */:
                    return next(Token.OpenParen);
                case 41 /* CloseParen */:
                    return next(Token.CloseParen);
                case 44 /* Comma */:
                    return next(Token.Comma);
                case 58 /* Colon */:
                    return next(Token.Colon);
                case 59 /* Semicolon */:
                    return next(Token.Semicolon);
                case 91 /* OpenBracket */:
                    return next(Token.OpenBracket);
                case 93 /* CloseBracket */:
                    return next(Token.CloseBracket);
                case 123 /* OpenBrace */:
                    return next(Token.OpenBrace);
                case 125 /* CloseBrace */:
                    return next(Token.CloseBrace);
                case 64 /* At */:
                    return next(Token.At);
                case 35 /* Hash */:
                    return next(Token.Hash);
                case 63 /* Question */:
                    return next(Token.Question);
                case 38 /* Ampersand */:
                    return next(Token.Ampersand);
                case 46 /* Dot */:
                    return lookAhead(1) === 46 /* Dot */ && lookAhead(2) === 46 /* Dot */
                        ? next(Token.Elipsis, 3)
                        : next(Token.Dot);
                case 47 /* Slash */:
                    switch (lookAhead(1)) {
                        case 47 /* Slash */:
                            return scanSingleLineComment();
                        case 42 /* Asterisk */:
                            return scanMultiLineComment();
                    }
                    return scanInvalidCharacter();
                case 43 /* Plus */:
                case 45 /* Minus */:
                    return isDigit(lookAhead(1)) ? scanSignedNumber() : scanInvalidCharacter();
                case 48 /* _0 */:
                    switch (lookAhead(1)) {
                        case 120 /* x */:
                            return scanHexNumber();
                        case 98 /* b */:
                            return scanBinaryNumber();
                    }
                // fallthrough
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */:
                    return scanNumber();
                case 60 /* LessThan */:
                    return isConflictMarker()
                        ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                        : next(Token.LessThan);
                case 62 /* GreaterThan */:
                    return isConflictMarker()
                        ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                        : next(Token.GreaterThan);
                case 61 /* Equals */:
                    return isConflictMarker()
                        ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                        : next(Token.Equals);
                case 124 /* Bar */:
                    return isConflictMarker()
                        ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                        : next(Token.Bar);
                case 34 /* DoubleQuote */:
                    return lookAhead(1) === 34 /* DoubleQuote */ && lookAhead(2) === 34 /* DoubleQuote */
                        ? scanTripleQuotedString()
                        : scanString();
                default:
                    if (isLowercaseAsciiLetter(ch)) {
                        return scanIdentifierOrKeyword();
                    }
                    if (isAsciiIdentifierStart(ch)) {
                        return scanIdentifier();
                    }
                    if (ch <= 127 /* MaxAscii */) {
                        return scanInvalidCharacter();
                    }
                    return scanNonAsciiToken();
            }
        }
        return (token = Token.EndOfFile);
    }
    function next(t, count = 1) {
        position += count;
        return (token = t);
    }
    function unterminated(t) {
        tokenFlags |= 4 /* Unterminated */;
        error({ code: "unterminated", format: { token: TokenDisplay[t] } });
        return (token = t);
    }
    function scanNonAsciiToken() {
        tokenFlags |= 8 /* NonAscii */;
        const ch = input.charCodeAt(position);
        if (isNonAsciiWhiteSpaceSingleLine(ch)) {
            return scanWhitespace();
        }
        let cp = input.codePointAt(position);
        if (isNonAsciiIdentifierCharacter(cp)) {
            return scanNonAsciiIdentifier(cp);
        }
        return scanInvalidCharacter();
    }
    function scanInvalidCharacter() {
        const codePoint = input.codePointAt(position);
        token = next(Token.Invalid, utf16CodeUnits(codePoint));
        error({ code: "invalid-character" });
        return token;
    }
    function isConflictMarker() {
        // Conflict markers must be at the start of a line.
        const ch = input.charCodeAt(position);
        if (position === 0 || isLineBreak(input.charCodeAt(position - 1))) {
            if (position + mergeConflictMarkerLength < input.length) {
                for (let i = 0; i < mergeConflictMarkerLength; i++) {
                    if (lookAhead(i) !== ch) {
                        return false;
                    }
                }
                return ch === 61 /* Equals */ || lookAhead(mergeConflictMarkerLength) === 32 /* Space */;
            }
        }
        return false;
    }
    function error(report) {
        const diagnostic = createDiagnostic({
            ...report,
            target: { file, pos: tokenPosition, end: position },
        });
        diagnosticHandler(diagnostic);
    }
    function scanWhitespace() {
        do {
            position++;
        } while (!eof() && isWhiteSpaceSingleLine(input.charCodeAt(position)));
        return (token = Token.Whitespace);
    }
    function scanSignedNumber() {
        position++; // consume '+/-'
        return scanNumber();
    }
    function scanNumber() {
        scanKnownDigits();
        if (!eof() && input.charCodeAt(position) === 46 /* Dot */) {
            position++;
            scanRequiredDigits();
        }
        if (!eof() && input.charCodeAt(position) === 101 /* e */) {
            position++;
            const ch = input.charCodeAt(position);
            if (ch === 43 /* Plus */ || ch === 45 /* Minus */) {
                position++;
            }
            scanRequiredDigits();
        }
        return (token = Token.NumericLiteral);
    }
    function scanKnownDigits() {
        do {
            position++;
        } while (!eof() && isDigit(input.charCodeAt(position)));
    }
    function scanRequiredDigits() {
        if (eof() || !isDigit(input.charCodeAt(position))) {
            error({ code: "digit-expected" });
            return;
        }
        scanKnownDigits();
    }
    function scanHexNumber() {
        position += 2; // consume '0x'
        if (eof() || !isHexDigit(input.charCodeAt(position))) {
            error({ code: "hex-digit-expected" });
            return (token = Token.NumericLiteral);
        }
        do {
            position++;
        } while (!eof() && isHexDigit(input.charCodeAt(position)));
        return (token = Token.NumericLiteral);
    }
    function scanBinaryNumber() {
        position += 2; // consume '0b'
        if (eof() || !isBinaryDigit(input.charCodeAt(position))) {
            error({ code: "binary-digit-expected" });
            return (token = Token.NumericLiteral);
        }
        do {
            position++;
        } while (!eof() && isBinaryDigit(input.charCodeAt(position)));
        return (token = Token.NumericLiteral);
    }
    function scanSingleLineComment() {
        position += 2; // consume '//'
        for (; !eof(); position++) {
            if (isLineBreak(input.charCodeAt(position))) {
                break;
            }
        }
        return (token = Token.SingleLineComment);
    }
    function scanMultiLineComment() {
        position += 2; // consume '/*'
        for (; !eof(); position++) {
            if (input.charCodeAt(position) === 42 /* Asterisk */ && lookAhead(1) === 47 /* Slash */) {
                position += 2;
                return (token = Token.MultiLineComment);
            }
        }
        return unterminated(Token.MultiLineComment);
    }
    function scanString() {
        position++; // consume '"'
        loop: for (; !eof(); position++) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 92 /* Backslash */:
                    tokenFlags |= 1 /* Escaped */;
                    position++;
                    if (eof()) {
                        break loop;
                    }
                    continue;
                case 34 /* DoubleQuote */:
                    position++;
                    return (token = Token.StringLiteral);
                case 13 /* CarriageReturn */:
                case 10 /* LineFeed */:
                    break loop;
            }
        }
        return unterminated(Token.StringLiteral);
    }
    function scanTripleQuotedString() {
        tokenFlags |= 2 /* TripleQuoted */;
        position += 3; // consume '"""'
        for (; !eof(); position++) {
            if (input.charCodeAt(position) === 34 /* DoubleQuote */ &&
                lookAhead(1) === 34 /* DoubleQuote */ &&
                lookAhead(2) === 34 /* DoubleQuote */) {
                position += 3;
                return (token = Token.StringLiteral);
            }
        }
        return unterminated(Token.StringLiteral);
    }
    function getStringTokenValue() {
        const quoteLength = tokenFlags & 2 /* TripleQuoted */ ? 3 : 1;
        const start = tokenPosition + quoteLength;
        const end = tokenFlags & 4 /* Unterminated */ ? position : position - quoteLength;
        if (tokenFlags & 2 /* TripleQuoted */) {
            return unindentAndUnescapeTripleQuotedString(start, end);
        }
        if (tokenFlags & 1 /* Escaped */) {
            return unescapeString(start, end);
        }
        return input.substring(start, end);
    }
    function getIdentifierTokenValue() {
        const text = getTokenText();
        return tokenFlags & 8 /* NonAscii */ ? text.normalize("NFC") : text;
    }
    function unindentAndUnescapeTripleQuotedString(start, end) {
        // ignore leading whitespace before required initial line break
        while (start < end && isWhiteSpaceSingleLine(input.charCodeAt(start))) {
            start++;
        }
        // remove required initial line break
        if (isLineBreak(input.charCodeAt(start))) {
            if (isCrlf(start, start, end)) {
                start++;
            }
            start++;
        }
        else {
            error({ code: "no-new-line-start-triple-quote" });
        }
        // remove whitespace before closing delimiter and record it as required
        // indentation for all lines
        const indentationEnd = end;
        while (end > start && isWhiteSpaceSingleLine(input.charCodeAt(end - 1))) {
            end--;
        }
        const indentationStart = end;
        // remove required final line break
        if (isLineBreak(input.charCodeAt(end - 1))) {
            if (isCrlf(end - 2, start, end)) {
                end--;
            }
            end--;
        }
        else {
            error({ code: "no-new-line-end-triple-quote" });
        }
        // remove required matching indentation from each line and unescape in the
        // process of doing so
        let result = "";
        let pos = start;
        while (pos < end) {
            // skip indentation at start of line
            start = skipMatchingIndentation(pos, end, indentationStart, indentationEnd);
            let ch;
            while (pos < end && !isLineBreak((ch = input.charCodeAt(pos)))) {
                if (ch !== 92 /* Backslash */) {
                    pos++;
                    continue;
                }
                result += input.substring(start, pos);
                if (pos === end - 1) {
                    error({ code: "invalid-escape-sequence" });
                    pos++;
                }
                else {
                    result += unescapeOne(pos);
                    pos += 2;
                }
                start = pos;
            }
            if (pos < end) {
                if (isCrlf(pos, start, end)) {
                    // CRLF in multi-line string is normalized to LF in string value.
                    // This keeps program behavior unchanged by line-eding conversion.
                    result += input.substring(start, pos);
                    result += "\n";
                    pos += 2;
                }
                else {
                    pos++; // include non-CRLF newline
                    result += input.substring(start, pos);
                }
                start = pos;
            }
        }
        result += input.substring(start, pos);
        return result;
    }
    function isCrlf(pos, start, end) {
        return (pos >= start &&
            pos < end - 1 &&
            input.charCodeAt(pos) === 13 /* CarriageReturn */ &&
            input.charCodeAt(pos + 1) === 10 /* LineFeed */);
    }
    function skipMatchingIndentation(pos, end, indentationStart, indentationEnd) {
        let indentationPos = indentationStart;
        end = Math.min(end, pos + (indentationEnd - indentationStart));
        while (pos < end) {
            const ch = input.charCodeAt(pos);
            if (isLineBreak(ch)) {
                // allow subset of indentation if line has only whitespace
                break;
            }
            if (ch !== input.charCodeAt(indentationPos)) {
                error({ code: "triple-quote-indent" });
                break;
            }
            indentationPos++;
            pos++;
        }
        return pos;
    }
    function unescapeString(start, end) {
        let result = "";
        let pos = start;
        while (pos < end) {
            let ch = input.charCodeAt(pos);
            if (ch !== 92 /* Backslash */) {
                pos++;
                continue;
            }
            if (pos === end - 1) {
                error({ code: "invalid-escape-sequence" });
                break;
            }
            result += input.substring(start, pos);
            result += unescapeOne(pos);
            pos += 2;
            start = pos;
        }
        result += input.substring(start, pos);
        return result;
    }
    function unescapeOne(pos) {
        const ch = input.charCodeAt(pos + 1);
        switch (ch) {
            case 114 /* r */:
                return "\r";
            case 110 /* n */:
                return "\n";
            case 116 /* t */:
                return "\t";
            case 34 /* DoubleQuote */:
                return '"';
            case 92 /* Backslash */:
                return "\\";
            default:
                error({ code: "invalid-escape-sequence" });
                return String.fromCharCode(ch);
        }
    }
    function scanIdentifierOrKeyword() {
        let key = 0;
        let count = 0;
        let ch = input.charCodeAt(position);
        while (true) {
            position++;
            count++;
            key = (key << 5) | (ch - 97 /* a */);
            if (eof()) {
                break;
            }
            ch = input.charCodeAt(position);
            if (count < 9 /* MaxLength */ && isLowercaseAsciiLetter(ch)) {
                continue;
            }
            if (isAsciiIdentifierContinue(ch)) {
                return scanIdentifier();
            }
            if (ch > 127 /* MaxAscii */) {
                const cp = input.codePointAt(position);
                if (isNonAsciiIdentifierCharacter(cp)) {
                    return scanNonAsciiIdentifier(cp);
                }
            }
            break;
        }
        if (count >= 2 /* MinLength */ && count <= 9 /* MaxLength */) {
            const keyword = KeywordMap.get(key);
            if (keyword) {
                return (token = keyword);
            }
        }
        return (token = Token.Identifier);
    }
    function scanIdentifier() {
        let ch;
        do {
            position++;
            if (eof()) {
                return (token = Token.Identifier);
            }
        } while (isAsciiIdentifierContinue((ch = input.charCodeAt(position))));
        if (ch > 127 /* MaxAscii */) {
            let cp = input.codePointAt(position);
            if (isNonAsciiIdentifierCharacter(cp)) {
                return scanNonAsciiIdentifier(cp);
            }
        }
        return (token = Token.Identifier);
    }
    function scanNonAsciiIdentifier(startCodePoint) {
        tokenFlags |= 8 /* NonAscii */;
        let cp = startCodePoint;
        do {
            position += utf16CodeUnits(cp);
        } while (!eof() && isIdentifierContinue((cp = input.codePointAt(position))));
        return (token = Token.Identifier);
    }
}
//# sourceMappingURL=scanner.js.map