import { Diagnostic, DiagnosticCreator, DiagnosticMap, DiagnosticMessages, DiagnosticTarget, LogSink, NoTarget, SourceFile, SourceLocation } from "./types.js";
/**
 * Create a new diagnostics creator.
 * @param diagnostics Map of the potential diagnostics.
 * @param libraryName Optional name of the library if in the scope of a library.
 * @returns @see DiagnosticCreator
 */
export declare function createDiagnosticCreator<T extends {
    [code: string]: DiagnosticMessages;
}>(diagnostics: DiagnosticMap<T>, libraryName?: string): DiagnosticCreator<T>;
/**
 * Represents a failure with multiple errors.
 */
export declare class AggregateError extends Error {
    readonly errors: readonly Error[];
    constructor(...errors: (Error | undefined)[]);
}
export declare type WriteLine = (text?: string) => void;
export declare type DiagnosticHandler = (diagnostic: Diagnostic) => void;
export declare function computeTargetLocation(target?: DiagnosticTarget | typeof NoTarget): SourceLocation | undefined;
export declare function logDiagnostics(diagnostics: readonly Diagnostic[], logger: LogSink): void;
export declare function formatDiagnostic(diagnostic: Diagnostic): string;
export declare function createSourceFile(text: string, path: string): SourceFile;
export declare function getSourceLocation(target: DiagnosticTarget): SourceLocation;
/**
 * Verbose output is enabled by default for runs in mocha explorer in VS Code,
 * where the output is nicely associated with the individual test, and disabled
 * by default for command line runs where we don't want to spam the console.
 *
 * If the steps taken to produce the message are expensive, pass a callback
 * instead of producing the message then passing it here only to be dropped
 * when verbose output is disabled.
 */
export declare function logVerboseTestOutput(messageOrCallback: string | ((log: LogSink) => void)): void;
export declare function dumpError(error: Error, logger: LogSink): void;
/**
 * Use this to report bugs in the compiler, and not errors in the source code
 * being compiled.
 *
 * @param condition Throw if this is not true.
 *
 * @param message Error message.
 *
 * @param target Optional location in source code that might give a clue about
 *               what got the compiler off track.
 */
export declare function compilerAssert(condition: any, message: string, target?: DiagnosticTarget): asserts condition;
//# sourceMappingURL=diagnostics.d.ts.map