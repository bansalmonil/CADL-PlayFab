import { compilerAssert } from "./diagnostics.js";
import { createDiagnostic } from "./messages.js";
import { visitChildren } from "./parser.js";
import { NoTarget, SyntaxKind, } from "./types.js";
// Use a regular expression to define the prefix for Cadl-exposed functions
// defined in JavaScript modules
const DecoratorFunctionPattern = /^\$/;
const SymbolTable = class extends Map {
    constructor() {
        super(...arguments);
        this.duplicates = new Set();
    }
    // First set for a given key wins, but record all duplicates for diagnostics.
    set(key, value) {
        const existing = this.get(key);
        if (existing === undefined) {
            super.set(key, value);
        }
        else {
            this.duplicates.add(existing);
            this.duplicates.add(value);
        }
        return this;
    }
};
export function createSymbolTable() {
    return new SymbolTable();
}
export function createBinder(program, options = {}) {
    let currentFile;
    let parentNode = options === null || options === void 0 ? void 0 : options.initialParentNode;
    let fileNamespace;
    let currentNamespace;
    let isJsFile = false;
    // Node where locals go.
    let scope;
    return {
        bindSourceFile,
        bindNode,
        bindJsSourceFile,
    };
    function isFunctionName(name) {
        return DecoratorFunctionPattern.test(name);
    }
    function getFunctionName(name) {
        return name.replace(DecoratorFunctionPattern, "");
    }
    function bindJsSourceFile(sourceFile) {
        sourceFile.exports = createSymbolTable();
        isJsFile = true;
        const rootNs = sourceFile.esmExports["namespace"];
        const namespaces = new Set();
        for (const [key, member] of Object.entries(sourceFile.esmExports)) {
            if (typeof member === "function" && isFunctionName(key)) {
                // lots of 'any' casts here because control flow narrowing `member` to Function
                // isn't particularly useful it turns out.
                const name = getFunctionName(key);
                if (name === "onBuild") {
                    try {
                        program.onBuild(member);
                        continue;
                    }
                    catch (err) {
                        if (program.compilerOptions.designTimeBuild) {
                            // do not exit the language server
                            program.reportDiagnostic(createDiagnostic({
                                code: "on-build-fail",
                                format: { error: err },
                                target: NoTarget,
                            }));
                            continue;
                        }
                        else {
                            throw err;
                        }
                    }
                }
                const memberNs = member.namespace;
                const nsParts = [];
                if (rootNs) {
                    nsParts.push(...rootNs.split("."));
                }
                if (memberNs) {
                    nsParts.push(...memberNs.split("."));
                }
                scope = sourceFile;
                for (const part of nsParts) {
                    const existingBinding = scope.exports.get(part);
                    if (existingBinding &&
                        existingBinding.kind === "type" &&
                        namespaces.has(existingBinding.node)) {
                        // since the namespace was "declared" as part of this source file,
                        // we can simply re-use it.
                        scope = existingBinding.node;
                    }
                    else {
                        // need to synthesize a namespace declaration node
                        // consider creating a "synthetic" node flag if necessary
                        const nsNode = createSyntheticNamespace(part);
                        if (existingBinding && existingBinding.kind === "type") {
                            nsNode.symbol = existingBinding;
                            nsNode.exports = existingBinding.node.exports;
                        }
                        else {
                            declareSymbol(scope.exports, nsNode, part);
                        }
                        namespaces.add(nsNode);
                        scope = nsNode;
                    }
                }
                const sym = createDecoratorSymbol(name, sourceFile.file.path, member);
                scope.exports.set(sym.name, sym);
            }
        }
        sourceFile.namespaces = Array.from(namespaces);
    }
    function bindSourceFile(sourceFile) {
        isJsFile = false;
        sourceFile.exports = createSymbolTable();
        fileNamespace = currentFile = sourceFile;
        currentNamespace = scope = fileNamespace;
        bindNode(sourceFile);
    }
    function bindNode(node) {
        if (!node)
            return;
        // set the node's parent since we're going for a walk anyway
        node.parent = parentNode;
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
                bindModelStatement(node);
                break;
            case SyntaxKind.InterfaceStatement:
                bindInterfaceStatement(node);
                break;
            case SyntaxKind.UnionStatement:
                bindUnionStatement(node);
                break;
            case SyntaxKind.AliasStatement:
                bindAliasStatement(node);
                break;
            case SyntaxKind.EnumStatement:
                bindEnumStatement(node);
                break;
            case SyntaxKind.NamespaceStatement:
                bindNamespaceStatement(node);
                break;
            case SyntaxKind.OperationStatement:
                bindOperationStatement(node);
                break;
            case SyntaxKind.TemplateParameterDeclaration:
                bindTemplateParameterDeclaration(node);
                break;
            case SyntaxKind.UsingStatement:
                bindUsingStatement(node);
                break;
        }
        const prevParent = parentNode;
        // set parent node when we walk into children
        parentNode = node;
        if (hasScope(node)) {
            const prevScope = scope;
            const prevNamespace = currentNamespace;
            scope = node;
            if (node.kind === SyntaxKind.NamespaceStatement) {
                currentNamespace = node;
            }
            visitChildren(node, bindNode);
            if (node.kind !== SyntaxKind.NamespaceStatement && node.locals) {
                program.reportDuplicateSymbols(node.locals);
            }
            scope = prevScope;
            currentNamespace = prevNamespace;
        }
        else {
            visitChildren(node, bindNode);
        }
        // restore parent node
        parentNode = prevParent;
    }
    function getContainingSymbolTable() {
        switch (scope.kind) {
            case SyntaxKind.NamespaceStatement:
                return scope.exports;
            case SyntaxKind.CadlScript:
                return fileNamespace.exports;
            case "JsSourceFile":
                return scope.exports;
            default:
                return scope.locals;
        }
    }
    function bindTemplateParameterDeclaration(node) {
        declareSymbol(getContainingSymbolTable(), node, node.id.sv);
    }
    function bindModelStatement(node) {
        declareSymbol(getContainingSymbolTable(), node, node.id.sv);
        // Initialize locals for type parameters
        node.locals = new SymbolTable();
    }
    function bindInterfaceStatement(node) {
        declareSymbol(getContainingSymbolTable(), node, node.id.sv);
        node.locals = new SymbolTable();
    }
    function bindUnionStatement(node) {
        declareSymbol(getContainingSymbolTable(), node, node.id.sv);
        node.locals = new SymbolTable();
    }
    function bindAliasStatement(node) {
        declareSymbol(getContainingSymbolTable(), node, node.id.sv);
        // Initialize locals for type parameters
        node.locals = new SymbolTable();
    }
    function bindEnumStatement(node) {
        declareSymbol(getContainingSymbolTable(), node, node.id.sv);
    }
    function bindNamespaceStatement(statement) {
        // check if there's an existing symbol for this namespace
        const existingBinding = currentNamespace.exports.get(statement.name.sv);
        if (existingBinding && existingBinding.kind === "type") {
            statement.symbol = existingBinding;
            // locals are never shared.
            statement.locals = new SymbolTable();
            // todo: don't merge exports
            statement.exports = existingBinding.node.exports;
        }
        else {
            declareSymbol(getContainingSymbolTable(), statement, statement.name.sv);
            // Initialize locals for non-exported symbols
            statement.locals = new SymbolTable();
            // initialize exports for exported symbols
            statement.exports = new SymbolTable();
        }
        currentFile.namespaces.push(statement);
        if (statement.statements === undefined) {
            scope = currentNamespace = statement;
            fileNamespace = statement;
            let current = statement;
            while (current.kind !== SyntaxKind.CadlScript) {
                currentFile.inScopeNamespaces.push(current);
                current = current.parent;
            }
        }
    }
    function bindUsingStatement(statement) {
        currentFile.usings.push(statement);
    }
    function bindOperationStatement(statement) {
        if (scope.kind !== SyntaxKind.InterfaceStatement) {
            declareSymbol(getContainingSymbolTable(), statement, statement.id.sv);
        }
    }
    function declareSymbol(table, node, name) {
        compilerAssert(table, "Attempted to declare symbol on non-existent table");
        const symbol = createTypeSymbol(node, name);
        node.symbol = symbol;
        if (scope.kind === SyntaxKind.NamespaceStatement) {
            compilerAssert(node.kind !== SyntaxKind.TemplateParameterDeclaration, "Attempted to declare template parameter in namespace", node);
            node.namespaceSymbol = scope.symbol;
        }
        else if (scope.kind === SyntaxKind.CadlScript) {
            compilerAssert(node.kind !== SyntaxKind.TemplateParameterDeclaration, "Attempted to declare template parameter in global scope", node);
            if (fileNamespace.kind !== SyntaxKind.CadlScript) {
                node.namespaceSymbol = fileNamespace.symbol;
            }
        }
        table.set(name, symbol);
    }
}
function hasScope(node) {
    switch (node.kind) {
        case SyntaxKind.ModelStatement:
        case SyntaxKind.AliasStatement:
            return true;
        case SyntaxKind.NamespaceStatement:
            return node.statements !== undefined;
        case SyntaxKind.CadlScript:
            return true;
        case SyntaxKind.InterfaceStatement:
            return true;
        case SyntaxKind.UnionStatement:
            return true;
        default:
            return false;
    }
}
function createTypeSymbol(node, name) {
    return {
        kind: "type",
        node,
        name,
    };
}
function createDecoratorSymbol(name, path, value) {
    return {
        kind: "decorator",
        name: `@` + name,
        path,
        value,
    };
}
function createSyntheticNamespace(name) {
    const nsId = {
        kind: SyntaxKind.Identifier,
        pos: 0,
        end: 0,
        sv: name,
    };
    return {
        kind: SyntaxKind.NamespaceStatement,
        decorators: [],
        pos: 0,
        end: 0,
        name: nsId,
        locals: createSymbolTable(),
        exports: createSymbolTable(),
    };
}
//# sourceMappingURL=binder.js.map