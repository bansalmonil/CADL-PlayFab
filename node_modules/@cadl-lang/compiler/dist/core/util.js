import fs from "fs";
import { readFile, realpath, stat, writeFile } from "fs/promises";
import fetch from "node-fetch";
import { isAbsolute, join, resolve } from "path";
import { fileURLToPath, pathToFileURL, URL } from "url";
import { createSourceFile } from "./diagnostics.js";
import { createConsoleSink } from "./logger.js";
import { createDiagnostic } from "./messages.js";
import { NoTarget } from "./types.js";
export const cadlVersion = getVersion();
function getVersion() {
    const packageJsonPath = fileURLToPath(new URL("../../package.json", import.meta.url));
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
    return packageJson.version;
}
export function deepFreeze(value) {
    if (Array.isArray(value)) {
        value.map(deepFreeze);
    }
    else if (typeof value === "object") {
        for (const prop in value) {
            deepFreeze(value[prop]);
        }
    }
    return Object.freeze(value);
}
export function deepClone(value) {
    if (Array.isArray(value)) {
        return value.map(deepClone);
    }
    if (typeof value === "object") {
        const obj = {};
        for (const prop in value) {
            obj[prop] = deepClone(value[prop]);
        }
        return obj;
    }
    return value;
}
export async function doIO(action, path, reportDiagnostic, options) {
    var _a;
    let result;
    try {
        result = await action(path);
    }
    catch (e) {
        let diagnostic;
        let target = (_a = options === null || options === void 0 ? void 0 : options.diagnosticTarget) !== null && _a !== void 0 ? _a : NoTarget;
        // blame the JS file, not the Cadl import statement for JS syntax errors.
        if (e instanceof SyntaxError && (options === null || options === void 0 ? void 0 : options.jsDiagnosticTarget)) {
            target = options.jsDiagnosticTarget;
        }
        switch (e.code) {
            case "ENOENT":
                if (options === null || options === void 0 ? void 0 : options.allowFileNotFound) {
                    return undefined;
                }
                diagnostic = createDiagnostic({ code: "file-not-found", target, format: { path } });
                break;
            default:
                diagnostic = createDiagnostic({
                    code: "file-load",
                    target,
                    format: { message: e.message },
                });
                break;
        }
        reportDiagnostic(diagnostic);
        return undefined;
    }
    return result;
}
export async function loadFile(host, path, load, reportDiagnostic, options) {
    const file = await doIO(host.readFile, path, reportDiagnostic, options);
    if (!file) {
        return [undefined, createSourceFile("", path)];
    }
    let data;
    try {
        data = load(file.text);
    }
    catch (e) {
        reportDiagnostic({
            code: "file-load",
            message: e.message,
            severity: "error",
            target: { file, pos: 1, end: 1 },
        });
        return [undefined, file];
    }
    return [data, file];
}
export const NodeHost = {
    readUrl: async (url) => {
        const response = await fetch(url);
        const text = await response.text();
        return createSourceFile(text, url);
    },
    readFile: async (path) => createSourceFile(await readFile(path, "utf-8"), path),
    writeFile: (path, content) => writeFile(path, content, { encoding: "utf-8" }),
    resolveAbsolutePath: (path) => resolve(path),
    getExecutionRoot: () => resolve(fileURLToPath(import.meta.url), "../../../"),
    getJsImport: (path) => import(pathToFileURL(path).href),
    getLibDirs() {
        const rootDir = this.getExecutionRoot();
        return [join(rootDir, "lib")];
    },
    stat(path) {
        return stat(path);
    },
    realpath(path) {
        return realpath(path);
    },
    logSink: createConsoleSink(),
};
export async function readUrlOrPath(host, pathOrUrl) {
    if (isUrl(pathOrUrl)) {
        return host.readUrl(pathOrUrl);
    }
    return host.readFile(pathOrUrl);
}
export function resolveRelativeUrlOrPath(base, relativeOrAbsolute) {
    if (isUrl(relativeOrAbsolute)) {
        return relativeOrAbsolute;
    }
    else if (isAbsolute(relativeOrAbsolute)) {
        return relativeOrAbsolute;
    }
    else if (isUrl(base)) {
        return new URL(relativeOrAbsolute, base).href;
    }
    else {
        return resolve(base, relativeOrAbsolute);
    }
}
function isUrl(url) {
    try {
        new URL(url);
        return true;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=util.js.map