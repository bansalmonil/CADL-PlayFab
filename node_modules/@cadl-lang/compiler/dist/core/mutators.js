import { createBinder } from "./binder.js";
import { createDiagnostic } from "./messages.js";
import { parse } from "./parser.js";
import { SyntaxKind, } from "./types.js";
function addProperty(program, model, modelNode, parentNode, propertyName, propertyTypeName, insertIndex) {
    // Parse a temporary model type to extract its property
    const fakeNode = parse(`model Fake { ${propertyName}: ${propertyTypeName}}`);
    if (fakeNode.parseDiagnostics.length > 0) {
        program.reportDiagnostic(createDiagnostic({
            code: "add-model-property-fail",
            format: { propertyName, propertyTypeName },
            target: model,
        }));
        program.reportDiagnostics(fakeNode.parseDiagnostics);
        return undefined;
    }
    const firstStatement = fakeNode.statements[0];
    const graftProperty = firstStatement.properties[0];
    // Fix up the source location of the nodes to match the model node that
    // contains the new property since we can't update the entire file's node
    // positions.
    graftProperty.pos = modelNode.pos;
    graftProperty.end = modelNode.end;
    // Create a binder to wire up the grafted property
    const binder = createBinder(program, {
        initialParentNode: parentNode,
    });
    binder.bindNode(graftProperty);
    // Evaluate the new property with the checker
    const newProperty = program.checker.checkModelProperty(graftProperty);
    // Put the property back into the node
    modelNode.properties.splice(insertIndex || modelNode.properties.length, 0, graftProperty);
    if (insertIndex !== undefined) {
        // Insert the property by adding it in the right order to a new Map
        let i = 0;
        const newProperties = new Map();
        for (let [name, prop] of model.properties.entries()) {
            if (i === insertIndex) {
                newProperties.set(newProperty.name, newProperty);
            }
            newProperties.set(name, prop);
            model.properties = newProperties;
            i++;
        }
    }
    else {
        model.properties.set(newProperty.name, newProperty);
    }
    return newProperty;
}
export function addModelProperty(program, model, propertyName, propertyTypeName) {
    if (model.node.kind !== SyntaxKind.ModelStatement) {
        program.reportDiagnostic(createDiagnostic({ code: "add-model-property", target: model }));
        return;
    }
    // Create the property and add it to the type
    const newProperty = addProperty(program, model, model.node, model.node, propertyName, propertyTypeName);
    if (newProperty) {
        model.properties.set(propertyName, newProperty);
        return newProperty;
    }
    return undefined;
}
export function addOperationParameter(program, operation, parameterName, parameterTypeName, options) {
    if (operation.node.kind !== SyntaxKind.OperationStatement) {
        program.reportDiagnostic(createDiagnostic({ code: "add-parameter", target: operation }));
        return;
    }
    // Create the property and add it to the type
    return addProperty(program, operation.parameters, operation.node.parameters, operation.node, parameterName, parameterTypeName, options === null || options === void 0 ? void 0 : options.insertIndex);
}
export function addOperationResponseType(program, operation, responseTypeName) {
    if (operation.node.kind !== SyntaxKind.OperationStatement) {
        program.reportDiagnostic(createDiagnostic({ code: "add-response", target: operation }));
        return;
    }
    // Parse a temporary operation to extract its response type
    const opNode = parse(`op Fake(): string | ${responseTypeName};`);
    if (opNode.parseDiagnostics.length > 0) {
        program.reportDiagnostic(createDiagnostic({
            code: "add-response-type",
            format: { responseTypeName, operationName: operation.name },
            target: operation,
        }));
        program.reportDiagnostics(opNode.parseDiagnostics);
        return undefined;
    }
    const graftUnion = opNode.statements[0]
        .returnType;
    // Graft the union into the operation
    const originalResponse = operation.node.returnType;
    graftUnion.options[0] = originalResponse;
    operation.node.returnType = graftUnion;
    // Create a binder to wire up the grafted property
    const binder = createBinder(program, {
        initialParentNode: operation.node,
    });
    binder.bindNode(graftUnion);
    // Evaluate the new response type with the checker
    operation.returnType = program.checker.checkUnionExpression(graftUnion);
}
//# sourceMappingURL=mutators.js.map