import { Program } from "./program";
/**
 * Type System types
 */
export declare type DecoratorArgument = Type | number | string | boolean;
export interface DecoratorApplication {
    decorator: DecoratorFunction;
    args: DecoratorArgument[];
}
export interface DecoratorFunction {
    (program: Program, target: Type, ...customArgs: any[]): void;
    namespace?: string;
}
export interface BaseType {
    kind: string;
    node?: Node;
    instantiationParameters?: Type[];
}
export interface DecoratedType {
    decorators: DecoratorApplication[];
}
export interface TemplatedType {
    templateArguments?: Type[];
    templateNode?: Node;
}
export declare type Type = ModelType | ModelTypeProperty | InterfaceType | EnumType | EnumMemberType | TemplateParameterType | NamespaceType | OperationType | StringLiteralType | NumericLiteralType | BooleanLiteralType | ArrayType | TupleType | UnionType | UnionTypeVariant | IntrinsicType;
export interface IntrinsicType extends BaseType {
    kind: "Intrinsic";
    name: string;
}
export interface ErrorType extends IntrinsicType {
    name: "ErrorType";
}
export declare type IntrinsicModelName = "bytes" | "int64" | "int32" | "int16" | "int8" | "uint64" | "uint32" | "uint16" | "uint8" | "safeint" | "float32" | "float64" | "string" | "plainDate" | "plainTime" | "zonedDateTime" | "boolean" | "null";
export interface ModelType extends BaseType, DecoratedType, TemplatedType {
    kind: "Model";
    name: IntrinsicModelName | string;
    node: ModelStatementNode | ModelExpressionNode | IntersectionExpressionNode;
    namespace?: NamespaceType;
    properties: Map<string, ModelTypeProperty>;
    baseModel?: ModelType;
}
export interface ModelTypeProperty extends DecoratedType {
    kind: "ModelProperty";
    node: ModelPropertyNode | ModelSpreadPropertyNode;
    name: string;
    type: Type;
    sourceProperty?: ModelTypeProperty;
    optional: boolean;
    default?: Type;
}
export interface InterfaceType extends BaseType, DecoratedType, TemplatedType {
    kind: "Interface";
    name: string;
    node: InterfaceStatementNode;
    namespace?: NamespaceType;
    operations: Map<string, OperationType>;
}
export interface EnumType extends BaseType, DecoratedType {
    kind: "Enum";
    name: string;
    node: EnumStatementNode;
    namespace?: NamespaceType;
    members: EnumMemberType[];
}
export interface EnumMemberType extends BaseType, DecoratedType {
    kind: "EnumMember";
    name: string;
    enum: EnumType;
    node: EnumMemberNode;
    value?: string | number;
}
export interface OperationType extends DecoratedType {
    kind: "Operation";
    node: OperationStatementNode;
    name: string;
    namespace?: NamespaceType;
    interface?: InterfaceType;
    parameters: ModelType;
    returnType: Type;
}
export interface NamespaceType extends BaseType, DecoratedType {
    kind: "Namespace";
    name: string;
    namespace?: NamespaceType;
    node: NamespaceStatementNode;
    models: Map<string, ModelType>;
    operations: Map<string, OperationType>;
    namespaces: Map<string, NamespaceType>;
    interfaces: Map<string, InterfaceType>;
    unions: Map<string, UnionType>;
}
export declare type LiteralType = StringLiteralType | NumericLiteralType | BooleanLiteralType;
export interface StringLiteralType extends BaseType {
    kind: "String";
    node: StringLiteralNode;
    value: string;
}
export interface NumericLiteralType extends BaseType {
    kind: "Number";
    node: NumericLiteralNode;
    value: number;
}
export interface BooleanLiteralType extends BaseType {
    kind: "Boolean";
    node: BooleanLiteralNode;
    value: boolean;
}
export interface ArrayType extends BaseType {
    kind: "Array";
    node: ArrayExpressionNode;
    elementType: Type;
}
export interface TupleType extends BaseType {
    kind: "Tuple";
    node: TupleExpressionNode;
    values: Type[];
}
export interface UnionType extends BaseType, DecoratedType, TemplatedType {
    kind: "Union";
    name?: string;
    node: UnionExpressionNode | UnionStatementNode;
    namespace?: NamespaceType;
    variants: Map<string | Symbol, Type>;
    expression: boolean;
    readonly options: Type[];
}
export interface UnionTypeVariant extends BaseType, DecoratedType {
    kind: "UnionVariant";
    name: string | Symbol;
    node: UnionVariantNode;
    type: Type;
}
export interface TemplateParameterType extends BaseType {
    kind: "TemplateParameter";
    node: TemplateParameterDeclarationNode;
}
export declare type Sym = DecoratorSymbol | TypeSymbol;
export interface DecoratorSymbol {
    kind: "decorator";
    path: string;
    name: string;
    value: (...args: any[]) => any;
}
export interface TypeSymbol {
    kind: "type";
    node: Node;
    name: string;
    id?: number;
}
export interface SymbolLinks {
    type?: Type;
    declaredType?: Type;
    instantiations?: TypeInstantiationMap;
}
export interface SymbolTable extends Map<string, Sym> {
    readonly duplicates: Set<Sym>;
}
/**
 * Maps type arguments to instantiated type.
 */
export interface TypeInstantiationMap {
    get(args: Type[]): Type | undefined;
    set(args: Type[], type: Type): void;
}
/**
 * AST types
 */
export declare enum SyntaxKind {
    CadlScript = 0,
    ImportStatement = 1,
    Identifier = 2,
    NamedImport = 3,
    DecoratorExpression = 4,
    DirectiveExpression = 5,
    MemberExpression = 6,
    NamespaceStatement = 7,
    UsingStatement = 8,
    OperationStatement = 9,
    ModelStatement = 10,
    ModelExpression = 11,
    ModelProperty = 12,
    ModelSpreadProperty = 13,
    InterfaceStatement = 14,
    UnionStatement = 15,
    UnionVariant = 16,
    EnumStatement = 17,
    EnumMember = 18,
    AliasStatement = 19,
    UnionExpression = 20,
    IntersectionExpression = 21,
    TupleExpression = 22,
    ArrayExpression = 23,
    StringLiteral = 24,
    NumericLiteral = 25,
    BooleanLiteral = 26,
    TypeReference = 27,
    TemplateParameterDeclaration = 28,
    EmptyStatement = 29,
    InvalidStatement = 30,
    LineComment = 31,
    BlockComment = 32
}
export interface BaseNode extends TextRange {
    kind: SyntaxKind;
    parent?: Node;
    directives?: DirectiveExpressionNode[];
}
export interface TemplateDeclarationNode {
    templateParameters: TemplateParameterDeclarationNode[];
    locals?: SymbolTable;
}
export declare type Node = CadlScriptNode | TemplateParameterDeclarationNode | ModelPropertyNode | UnionVariantNode | OperationStatementNode | NamedImportNode | EnumMemberNode | ModelSpreadPropertyNode | DecoratorExpressionNode | DirectiveExpressionNode | Statement | Expression;
export declare type Comment = LineComment | BlockComment;
export interface LineComment extends TextRange {
    kind: SyntaxKind.LineComment;
}
export interface BlockComment extends TextRange {
    kind: SyntaxKind.BlockComment;
}
export interface CadlScriptNode extends ContainerNode, BaseNode {
    kind: SyntaxKind.CadlScript;
    statements: Statement[];
    file: SourceFile;
    inScopeNamespaces: NamespaceStatementNode[];
    namespaces: NamespaceStatementNode[];
    usings: UsingStatementNode[];
    comments: Comment[];
    parseDiagnostics: Diagnostic[];
    printable: boolean;
}
export declare type Statement = ImportStatementNode | ModelStatementNode | NamespaceStatementNode | InterfaceStatementNode | UnionStatementNode | UsingStatementNode | EnumStatementNode | AliasStatementNode | OperationStatementNode | EmptyStatementNode | InvalidStatementNode;
export interface DeclarationNode {
    symbol?: TypeSymbol;
    namespaceSymbol?: TypeSymbol;
}
export declare type Declaration = ModelStatementNode | InterfaceStatementNode | UnionStatementNode | NamespaceStatementNode | OperationStatementNode | TemplateParameterDeclarationNode | EnumStatementNode | AliasStatementNode;
export declare type ScopeNode = NamespaceStatementNode | ModelStatementNode | InterfaceStatementNode | AliasStatementNode | CadlScriptNode;
export interface ImportStatementNode extends BaseNode {
    kind: SyntaxKind.ImportStatement;
    path: StringLiteralNode;
}
export interface IdentifierNode extends BaseNode {
    kind: SyntaxKind.Identifier;
    sv: string;
}
export interface NamedImportNode extends BaseNode {
    kind: SyntaxKind.NamedImport;
    id: IdentifierNode;
}
export interface DecoratorExpressionNode extends BaseNode {
    kind: SyntaxKind.DecoratorExpression;
    target: IdentifierNode | MemberExpressionNode;
    arguments: Expression[];
}
export interface DirectiveExpressionNode extends BaseNode {
    kind: SyntaxKind.DirectiveExpression;
    target: IdentifierNode;
    arguments: DirectiveArgument[];
}
export declare type DirectiveArgument = StringLiteralNode | IdentifierNode;
export declare type Expression = ArrayExpressionNode | MemberExpressionNode | ModelExpressionNode | TupleExpressionNode | UnionExpressionNode | IntersectionExpressionNode | TypeReferenceNode | IdentifierNode | StringLiteralNode | NumericLiteralNode | BooleanLiteralNode;
export declare type ReferenceExpression = TypeReferenceNode | MemberExpressionNode | IdentifierNode;
export interface MemberExpressionNode extends BaseNode {
    kind: SyntaxKind.MemberExpression;
    id: IdentifierNode;
    base: MemberExpressionNode | IdentifierNode;
}
export interface ContainerNode {
    locals?: SymbolTable;
    exports?: SymbolTable;
}
export interface NamespaceStatementNode extends BaseNode, DeclarationNode, ContainerNode {
    kind: SyntaxKind.NamespaceStatement;
    name: IdentifierNode;
    statements?: Statement[] | NamespaceStatementNode;
    decorators: DecoratorExpressionNode[];
}
export interface UsingStatementNode extends BaseNode {
    kind: SyntaxKind.UsingStatement;
    name: IdentifierNode | MemberExpressionNode;
}
export interface OperationStatementNode extends BaseNode, DeclarationNode {
    kind: SyntaxKind.OperationStatement;
    id: IdentifierNode;
    parameters: ModelExpressionNode;
    returnType: Expression;
    decorators: DecoratorExpressionNode[];
}
export interface ModelStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    kind: SyntaxKind.ModelStatement;
    id: IdentifierNode;
    properties: (ModelPropertyNode | ModelSpreadPropertyNode)[];
    extends?: ReferenceExpression;
    is?: ReferenceExpression;
    decorators: DecoratorExpressionNode[];
}
export interface InterfaceStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    kind: SyntaxKind.InterfaceStatement;
    id: IdentifierNode;
    operations: OperationStatementNode[];
    mixes: ReferenceExpression[];
    decorators: DecoratorExpressionNode[];
}
export interface UnionStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    kind: SyntaxKind.UnionStatement;
    id: IdentifierNode;
    options: UnionVariantNode[];
    decorators: DecoratorExpressionNode[];
}
export interface UnionVariantNode extends BaseNode {
    kind: SyntaxKind.UnionVariant;
    id: IdentifierNode | StringLiteralNode;
    value: Expression;
    decorators: DecoratorExpressionNode[];
}
export interface EnumStatementNode extends BaseNode, DeclarationNode {
    kind: SyntaxKind.EnumStatement;
    id: IdentifierNode;
    members: EnumMemberNode[];
    decorators: DecoratorExpressionNode[];
}
export interface EnumMemberNode extends BaseNode {
    kind: SyntaxKind.EnumMember;
    id: IdentifierNode | StringLiteralNode;
    value?: StringLiteralNode | NumericLiteralNode;
    decorators: DecoratorExpressionNode[];
}
export interface AliasStatementNode extends BaseNode, DeclarationNode, TemplateDeclarationNode {
    kind: SyntaxKind.AliasStatement;
    id: IdentifierNode;
    value: Expression;
}
export interface InvalidStatementNode extends BaseNode {
    kind: SyntaxKind.InvalidStatement;
}
export interface EmptyStatementNode extends BaseNode {
    kind: SyntaxKind.EmptyStatement;
}
export interface ModelExpressionNode extends BaseNode {
    kind: SyntaxKind.ModelExpression;
    properties: (ModelPropertyNode | ModelSpreadPropertyNode)[];
}
export interface ArrayExpressionNode extends BaseNode {
    kind: SyntaxKind.ArrayExpression;
    elementType: Expression;
}
export interface TupleExpressionNode extends BaseNode {
    kind: SyntaxKind.TupleExpression;
    values: Expression[];
}
export interface ModelPropertyNode extends BaseNode {
    kind: SyntaxKind.ModelProperty;
    id: IdentifierNode | StringLiteralNode;
    value: Expression;
    decorators: DecoratorExpressionNode[];
    optional: boolean;
    default?: Expression;
}
export interface ModelSpreadPropertyNode extends BaseNode {
    kind: SyntaxKind.ModelSpreadProperty;
    target: ReferenceExpression;
}
export declare type LiteralNode = StringLiteralNode | NumericLiteralNode | BooleanLiteralNode;
export interface StringLiteralNode extends BaseNode {
    kind: SyntaxKind.StringLiteral;
    value: string;
}
export interface NumericLiteralNode extends BaseNode {
    kind: SyntaxKind.NumericLiteral;
    value: number;
}
export interface BooleanLiteralNode extends BaseNode {
    kind: SyntaxKind.BooleanLiteral;
    value: boolean;
}
export interface UnionExpressionNode extends BaseNode {
    kind: SyntaxKind.UnionExpression;
    options: Expression[];
}
export interface IntersectionExpressionNode extends BaseNode {
    kind: SyntaxKind.IntersectionExpression;
    options: Expression[];
}
export interface TypeReferenceNode extends BaseNode {
    kind: SyntaxKind.TypeReference;
    target: ReferenceExpression;
    arguments: Expression[];
}
export interface TemplateParameterDeclarationNode extends BaseNode {
    kind: SyntaxKind.TemplateParameterDeclaration;
    id: IdentifierNode;
    symbol?: TypeSymbol;
}
/**
 * Identifies the position within a source file by line number and offset from
 * beginning of line.
 */
export interface LineAndCharacter {
    /** The line number. 0-based. */
    line: number;
    /**
     * The offset in UTF-16 code units to the character from the beginning of the
     * line. 0-based.
     *
     * NOTE: This is not necessarily the same as what a given text editor might
     * call the "column". Tabs, combining characters, surrogate pairs, and so on
     * can all cause an editor to report the column differently. Indeed, different
     * text editors report different column numbers for the same position in a
     * given document.
     */
    character: number;
}
export interface JsSourceFile {
    kind: "JsSourceFile";
    file: SourceFile;
    esmExports: any;
    exports?: SymbolTable;
    namespaces: NamespaceStatementNode[];
}
export interface SourceFile {
    /** The source code text. */
    readonly text: string;
    /**
     * The source file path.
     *
     * This is used only for diagnostics. The command line compiler will populate
     * it with the actual path from which the file was read, but it can actually
     * be an aribitrary name for other scenarios.
     */
    readonly path: string;
    /**
     * Array of positions in the text where each line begins. There is one entry
     * per line, in order of lines, and each entry represents the offset in UTF-16
     * code units from the start of the document to the beginning of the line.
     */
    getLineStarts(): readonly number[];
    /**
     * Converts a one-dimensional position in the document (measured in UTF-16
     * code units) to line number and offset from line start.
     */
    getLineAndCharacterOfPosition(position: number): LineAndCharacter;
}
export interface TextRange {
    /**
     * The starting position of the ranger measured in UTF-16 code units from the
     * start of the full string. Inclusive.
     */
    pos: number;
    /**
     * The ending position measured in UTF-16 code units from the start of the
     * full string. Exclusive.
     */
    end: number;
}
export interface SourceLocation extends TextRange {
    file: SourceFile;
}
export declare const NoTarget: unique symbol;
export declare type DiagnosticTarget = Node | Type | Sym | SourceLocation;
export declare type DiagnosticSeverity = "error" | "warning";
export interface Diagnostic {
    code: string;
    severity: DiagnosticSeverity;
    message: string;
    target: DiagnosticTarget | typeof NoTarget;
}
export interface DirectiveBase {
    node: DirectiveExpressionNode;
}
export declare type Directive = SuppressDirective;
export interface SuppressDirective extends DirectiveBase {
    name: "suppress";
    code: string;
    message: string;
}
export interface Dirent {
    isFile(): boolean;
    name: string;
    isDirectory(): boolean;
}
export interface CompilerHost {
    readUrl(url: string): Promise<SourceFile>;
    readFile(path: string): Promise<SourceFile>;
    /**
     * Write the file.
     * @param path Path to the file.
     * @param content Content of the file.
     */
    writeFile(path: string, content: string): Promise<void>;
    getExecutionRoot(): string;
    getLibDirs(): string[];
    getJsImport(path: string): Promise<any>;
    resolveAbsolutePath(path: string): string;
    stat(path: string): Promise<{
        isDirectory(): boolean;
        isFile(): boolean;
    }>;
    realpath(path: string): Promise<string>;
    logSink: LogSink;
}
declare type UnionToIntersection<T> = (T extends any ? (k: T) => void : never) extends (k: infer I) => void ? I : never;
declare type ListenerForType<T extends Type> = T extends Type ? {
    [k in Uncapitalize<T["kind"]>]?: (context: T) => void;
} : never;
declare type TypeListeners = UnionToIntersection<ListenerForType<Type>>;
export declare type SemanticNodeListener = {
    root?: (context: Program) => void;
} & TypeListeners;
export declare type DiagnosticReport<T extends {
    [code: string]: DiagnosticMessages;
}, C extends keyof T, M extends keyof T[C] = "default"> = {
    code: C;
    messageId?: M;
    target: DiagnosticTarget | typeof NoTarget;
} & DiagnosticFormat<T, C, M>;
export declare type DiagnosticFormat<T extends {
    [code: string]: DiagnosticMessages;
}, C extends keyof T, M extends keyof T[C] = "default"> = T[C][M] extends CallableMessage<infer A> ? {
    format: Record<A[number], string>;
} : {};
export interface DiagnosticDefinition<M extends DiagnosticMessages> {
    readonly severity: "warning" | "error";
    readonly messages: M;
}
export interface DiagnosticMessages {
    readonly [messageId: string]: string | CallableMessage<string[]>;
}
export interface CallableMessage<T extends string[]> {
    keys: T;
    (dict: Record<T[number], string>): string;
}
export declare type DiagnosticMap<T extends {
    [code: string]: DiagnosticMessages;
}> = {
    readonly [code in keyof T]: DiagnosticDefinition<T[code]>;
};
export interface DiagnosticCreator<T extends {
    [code: string]: DiagnosticMessages;
}> {
    readonly type: T;
    readonly diagnostics: DiagnosticMap<T>;
    createDiagnostic<C extends keyof T, M extends keyof T[C] = "default">(diag: DiagnosticReport<T, C, M>): Diagnostic;
    reportDiagnostic<C extends keyof T, M extends keyof T[C] = "default">(program: Program, diag: DiagnosticReport<T, C, M>): void;
}
export declare type TypeOfDiagnostics<T extends DiagnosticMap<any>> = T extends DiagnosticMap<infer D> ? D : never;
/**
 * Definition of a cadle library
 */
export interface CadlLibraryDef<T extends {
    [code: string]: DiagnosticMessages;
}> {
    /**
     * Name of the library. Must match the package.json name.
     */
    readonly name: string;
    /**
     * Map of potential diagnostics that can be emitted in this library where the key is the diagnostic code.
     */
    readonly diagnostics: DiagnosticMap<T>;
}
export interface CadlLibrary<T extends {
    [code: string]: DiagnosticMessages;
}> {
    readonly name: string;
    readonly diagnostics: DiagnosticMap<T>;
    reportDiagnostic<C extends keyof T, M extends keyof T[C] = "default">(program: Program, diag: DiagnosticReport<T, C, M>): void;
}
export declare type LogLevel = "debug" | "verbose" | "info" | "warning" | "error";
export interface LogInfo {
    level: LogLevel;
    message: string;
    code?: string;
    target?: DiagnosticTarget | typeof NoTarget;
}
export interface ProcessedLog {
    level: LogLevel;
    message: string;
    code?: string;
    sourceLocation?: SourceLocation;
}
export interface LogSink {
    log(log: ProcessedLog): void;
}
export interface Logger {
    debug(message: string): void;
    verbose(message: string): void;
    info(message: string): void;
    warn(message: string): void;
    error(message: string): void;
    log(log: LogInfo): void;
}
export {};
//# sourceMappingURL=types.d.ts.map