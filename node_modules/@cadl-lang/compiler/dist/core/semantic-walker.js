export function navigateProgram(program, listeners) {
    const eventEmitter = listeners instanceof EventEmitter ? listeners : createEventEmitter(listeners);
    const visited = new Set();
    eventEmitter.emit("root", program);
    if (!program.checker) {
        return;
    }
    navigateNamespaceType(program.checker.getGlobalNamespaceType(), eventEmitter, visited);
}
function navigateNamespaceType(namespace, eventEmitter, visited) {
    eventEmitter.emit("namespace", namespace);
    for (const model of namespace.models.values()) {
        navigateModelType(model, eventEmitter, visited);
    }
    for (const operation of namespace.operations.values()) {
        navigateOperationType(operation, eventEmitter, visited);
    }
    for (const subNamespace of namespace.namespaces.values()) {
        navigateNamespaceType(subNamespace, eventEmitter, visited);
    }
    for (const union of namespace.unions.values()) {
        navigateUnionType(union, eventEmitter, visited);
    }
    for (const iface of namespace.interfaces.values()) {
        navigateInterfaceType(iface, eventEmitter, visited);
    }
}
function checkVisited(visited, item) {
    if (visited.has(item)) {
        return true;
    }
    visited.add(item);
    return false;
}
function navigateOperationType(operation, eventEmitter, visited) {
    if (checkVisited(visited, operation)) {
        return;
    }
    eventEmitter.emit("operation", operation);
    for (const parameter of operation.parameters.properties.values()) {
        navigateType(parameter, eventEmitter, visited);
    }
    navigateType(operation.returnType, eventEmitter, visited);
}
function navigateModelType(model, eventEmitter, visited) {
    if (checkVisited(visited, model)) {
        return;
    }
    eventEmitter.emit("model", model);
    for (const property of model.properties.values()) {
        navigateModelTypeProperty(property, eventEmitter, visited);
    }
    if (model.baseModel) {
        navigateModelType(model.baseModel, eventEmitter, visited);
    }
}
function navigateModelTypeProperty(property, eventEmitter, visited) {
    if (checkVisited(visited, property)) {
        return;
    }
    eventEmitter.emit("modelProperty", property);
    navigateType(property.type, eventEmitter, visited);
}
function navigateInterfaceType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("interface", type);
    for (const op of type.operations.values()) {
        navigateType(op, eventEmitter, visited);
    }
}
function navigateArrayType(array, eventEmitter, visited) {
    if (checkVisited(visited, array)) {
        return;
    }
    eventEmitter.emit("array", array);
    navigateType(array.elementType, eventEmitter, visited);
}
function navigateEnumType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("enum", type);
}
function navigateUnionType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("union", type);
    for (const variant of type.variants.values()) {
        navigateType(variant, eventEmitter, visited);
    }
}
function navigateUnionTypeVariant(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("unionVariant", type);
    navigateType(type.type, eventEmitter, visited);
}
function navigateTupleType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("tuple", type);
    for (const value of type.values) {
        navigateType(value, eventEmitter, visited);
    }
}
function navigateTemplateParameter(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("templateParameter", type);
}
function navigateType(type, eventEmitter, visited) {
    switch (type.kind) {
        case "Model":
            return navigateModelType(type, eventEmitter, visited);
        case "ModelProperty":
            return navigateModelTypeProperty(type, eventEmitter, visited);
        case "Namespace":
            return navigateNamespaceType(type, eventEmitter, visited);
        case "Interface":
            return navigateInterfaceType(type, eventEmitter, visited);
        case "Array":
            return navigateArrayType(type, eventEmitter, visited);
        case "Enum":
            return navigateEnumType(type, eventEmitter, visited);
        case "Operation":
            return navigateOperationType(type, eventEmitter, visited);
        case "Union":
            return navigateUnionType(type, eventEmitter, visited);
        case "UnionVariant":
            return navigateUnionTypeVariant(type, eventEmitter, visited);
        case "Tuple":
            return navigateTupleType(type, eventEmitter, visited);
        case "TemplateParameter":
            return navigateTemplateParameter(type, eventEmitter, visited);
        case "Boolean":
        case "EnumMember":
        case "Intrinsic":
        case "Number":
        case "String":
            return;
        default:
            // Dummy const to ensure we handle all types.
            // If you get an error here, add a case for the new type you added
            const assertNever = type;
            return;
    }
}
export class EventEmitter {
    constructor() {
        this.listeners = new Map();
    }
    on(name, listener) {
        const array = this.listeners.get(name);
        if (array) {
            array.push(listener);
        }
        else {
            this.listeners.set(name, [listener]);
        }
    }
    emit(name, ...args) {
        const listeners = this.listeners.get(name);
        if (listeners) {
            for (const listener of listeners) {
                listener(...args);
            }
        }
    }
}
function createEventEmitter(listeners) {
    const eventEmitter = new EventEmitter();
    for (const [name, listener] of Object.entries(listeners)) {
        eventEmitter.on(name, listener);
    }
    return eventEmitter;
}
//# sourceMappingURL=semantic-walker.js.map