var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _MultiKeyMap_currentId, _MultiKeyMap_idMap, _MultiKeyMap_items;
import { createSymbolTable } from "./binder.js";
import { compilerAssert } from "./diagnostics.js";
import { createDiagnostic } from "./messages.js";
import { hasParseError } from "./parser.js";
import { SyntaxKind, } from "./types.js";
/**
 * A map keyed by a set of objects.
 *
 * This is likely non-optimal.
 */
class MultiKeyMap {
    constructor() {
        _MultiKeyMap_currentId.set(this, 0);
        _MultiKeyMap_idMap.set(this, new WeakMap());
        _MultiKeyMap_items.set(this, new Map());
    }
    get(items) {
        return __classPrivateFieldGet(this, _MultiKeyMap_items, "f").get(this.compositeKeyFor(items));
    }
    set(items, value) {
        const key = this.compositeKeyFor(items);
        __classPrivateFieldGet(this, _MultiKeyMap_items, "f").set(key, value);
    }
    compositeKeyFor(items) {
        return items.map((i) => this.keyFor(i)).join(",");
    }
    keyFor(item) {
        var _a, _b;
        if (__classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").has(item)) {
            return __classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").get(item);
        }
        const id = (__classPrivateFieldSet(this, _MultiKeyMap_currentId, (_b = __classPrivateFieldGet(this, _MultiKeyMap_currentId, "f"), _a = _b++, _b), "f"), _a);
        __classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").set(item, id);
        return id;
    }
}
_MultiKeyMap_currentId = new WeakMap(), _MultiKeyMap_idMap = new WeakMap(), _MultiKeyMap_items = new WeakMap();
/**
 * Maps type arguments to type instantiation.
 */
const TypeInstantiationMap = class extends MultiKeyMap {
};
export function createChecker(program) {
    var _a;
    let templateInstantiation = [];
    let instantiatingTemplate;
    let currentSymbolId = 0;
    const symbolLinks = new Map();
    const mergedSymbols = new Map();
    const globalNamespaceNode = createGlobalNamespaceNode();
    const globalNamespaceType = createGlobalNamespaceType();
    let cadlNamespaceNode;
    const errorType = { kind: "Intrinsic", name: "ErrorType" };
    // This variable holds on to the model type that is currently
    // being instantiated in checkModelStatement so that it is
    // possible to have recursive type references in properties.
    let pendingModelType = undefined;
    for (const file of program.jsSourceFiles.values()) {
        mergeJsSourceFile(file);
    }
    for (const file of program.sourceFiles.values()) {
        mergeCadlSourceFile(file);
    }
    for (const file of program.sourceFiles.values()) {
        setUsingsForFile(file);
    }
    const cadlNamespaceBinding = (_a = globalNamespaceNode.exports) === null || _a === void 0 ? void 0 : _a.get("Cadl");
    if (cadlNamespaceBinding) {
        // the cadl namespace binding will be absent if we've passed
        // the no-std-lib option.
        compilerAssert(cadlNamespaceBinding.kind === "type", "expected Cadl to be a type binding");
        compilerAssert(cadlNamespaceBinding.node.kind === SyntaxKind.NamespaceStatement, "expected Cadl to be a namespace");
        cadlNamespaceNode = cadlNamespaceBinding.node;
        for (const file of program.sourceFiles.values()) {
            for (const [name, binding] of cadlNamespaceNode.exports) {
                file.locals.set(name, binding);
            }
        }
    }
    return {
        getTypeForNode,
        checkProgram,
        checkSourceFile,
        checkModelProperty,
        checkUnionExpression,
        getLiteralType,
        getTypeName,
        getNamespaceString,
        getGlobalNamespaceType,
        getGlobalNamespaceNode,
        mergeJsSourceFile,
        mergeCadlSourceFile,
        setUsingsForFile,
        getMergedSymbol,
        getMergedNamespace,
        cloneType,
    };
    function mergeJsSourceFile(file) {
        mergeSymbolTable(file.exports, globalNamespaceNode.exports);
    }
    function mergeCadlSourceFile(file) {
        mergeSymbolTable(file.exports, globalNamespaceNode.exports);
    }
    function setUsingsForFile(file) {
        for (const using of file.usings) {
            const parentNs = using.parent;
            const sym = resolveTypeReference(using.name);
            if (!sym) {
                continue;
            }
            if (sym.kind === "decorator") {
                program.reportDiagnostic(createDiagnostic({ code: "using-invalid-ref", messageId: "decorator", target: using }));
                continue;
            }
            if (sym.node.kind !== SyntaxKind.NamespaceStatement) {
                program.reportDiagnostic(createDiagnostic({ code: "using-invalid-ref", target: using }));
                continue;
            }
            for (const [name, binding] of sym.node.exports) {
                parentNs.locals.set(name, binding);
            }
        }
        if (cadlNamespaceNode) {
            for (const [name, binding] of cadlNamespaceNode.exports) {
                file.locals.set(name, binding);
            }
        }
    }
    function getTypeForNode(node) {
        switch (node.kind) {
            case SyntaxKind.ModelExpression:
                return checkModel(node);
            case SyntaxKind.ModelStatement:
                return checkModel(node);
            case SyntaxKind.ModelProperty:
                return checkModelProperty(node);
            case SyntaxKind.AliasStatement:
                return checkAlias(node);
            case SyntaxKind.EnumStatement:
                return checkEnum(node);
            case SyntaxKind.InterfaceStatement:
                return checkInterface(node);
            case SyntaxKind.UnionStatement:
                return checkUnion(node);
            case SyntaxKind.NamespaceStatement:
                return checkNamespace(node);
            case SyntaxKind.OperationStatement:
                return checkOperation(node);
            case SyntaxKind.NumericLiteral:
                return checkNumericLiteral(node);
            case SyntaxKind.BooleanLiteral:
                return checkBooleanLiteral(node);
            case SyntaxKind.TupleExpression:
                return checkTupleExpression(node);
            case SyntaxKind.StringLiteral:
                return checkStringLiteral(node);
            case SyntaxKind.ArrayExpression:
                return checkArrayExpression(node);
            case SyntaxKind.UnionExpression:
                return checkUnionExpression(node);
            case SyntaxKind.IntersectionExpression:
                return checkIntersectionExpression(node);
            case SyntaxKind.TypeReference:
                return checkTypeReference(node);
            case SyntaxKind.TemplateParameterDeclaration:
                return checkTemplateParameterDeclaration(node);
        }
        return errorType;
    }
    function getTypeName(type) {
        switch (type.kind) {
            case "Model":
                return getModelName(type);
            case "Enum":
                return getEnumName(type);
            case "Union":
                return type.options.map(getTypeName).join(" | ");
            case "Array":
                return getTypeName(type.elementType) + "[]";
            case "String":
            case "Number":
            case "Boolean":
                return type.value.toString();
        }
        return "(unnamed type)";
    }
    function getNamespaceString(type) {
        if (!type)
            return "";
        const parent = type.namespace;
        return parent && parent.name !== "" ? `${getNamespaceString(parent)}.${type.name}` : type.name;
    }
    function getEnumName(e) {
        const nsName = getNamespaceString(e.namespace);
        return nsName ? `${nsName}.${e.name}` : e.name;
    }
    function getModelName(model) {
        var _a;
        const nsName = getNamespaceString(model.namespace);
        const modelName = (nsName ? nsName + "." : "") + (model.name || "(anonymous model)");
        if (model.templateArguments && model.templateArguments.length > 0) {
            // template instantiation
            const args = model.templateArguments.map(getTypeName);
            return `${modelName}<${args.join(", ")}>`;
        }
        else if (((_a = model.node.templateParameters) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            // template
            const params = model.node.templateParameters.map((t) => t.id.sv);
            return `${model.name}<${params.join(", ")}>`;
        }
        else {
            // regular old model.
            return modelName;
        }
    }
    function checkTemplateParameterDeclaration(node) {
        const parentNode = node.parent;
        if (instantiatingTemplate === parentNode) {
            const index = parentNode.templateParameters.findIndex((v) => v === node);
            return templateInstantiation[index];
        }
        return createType({
            kind: "TemplateParameter",
            node: node,
        });
    }
    function checkTypeReference(node) {
        const sym = resolveTypeReference(node);
        if (!sym) {
            return errorType;
        }
        if (sym.kind === "decorator") {
            program.reportDiagnostic(createDiagnostic({ code: "invalid-type-ref", messageId: "decorator", target: node }));
            return errorType;
        }
        const symbolLinks = getSymbolLinks(sym);
        let args = node.arguments.map(getTypeForNode);
        if (sym.node.kind === SyntaxKind.ModelStatement ||
            sym.node.kind === SyntaxKind.AliasStatement ||
            sym.node.kind === SyntaxKind.InterfaceStatement ||
            sym.node.kind === SyntaxKind.UnionStatement) {
            if (sym.node.templateParameters.length === 0) {
                if (args.length > 0) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-template-args",
                        messageId: "notTemplate",
                        target: node,
                    }));
                }
                if (symbolLinks.declaredType) {
                    return symbolLinks.declaredType;
                }
                else if (pendingModelType && pendingModelType.id.sv === sym.node.id.sv) {
                    return pendingModelType.type;
                }
                return sym.node.kind === SyntaxKind.ModelStatement
                    ? checkModelStatement(sym.node)
                    : sym.node.kind === SyntaxKind.AliasStatement
                        ? checkAlias(sym.node)
                        : sym.node.kind === SyntaxKind.InterfaceStatement
                            ? checkInterface(sym.node)
                            : checkUnion(sym.node);
            }
            else {
                // declaration is templated, lets instantiate.
                if (!symbolLinks.declaredType) {
                    // we haven't checked the declared type yet, so do so.
                    sym.node.kind === SyntaxKind.ModelStatement
                        ? checkModelStatement(sym.node)
                        : sym.node.kind === SyntaxKind.AliasStatement
                            ? checkAlias(sym.node)
                            : sym.node.kind === SyntaxKind.InterfaceStatement
                                ? checkInterface(sym.node)
                                : checkUnion(sym.node);
                }
                const templateParameters = sym.node.templateParameters;
                if (args.length < templateParameters.length) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-template-args",
                        messageId: "tooFew",
                        target: node,
                    }));
                    args = [...args, ...new Array(templateParameters.length - args.length).fill(errorType)];
                }
                else if (args.length > templateParameters.length) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-template-args",
                        messageId: "tooMany",
                        target: node,
                    }));
                    args = args.slice(0, templateParameters.length);
                }
                return instantiateTemplate(sym.node, args);
            }
        }
        // some other kind of reference
        if (args.length > 0) {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-template-args",
                messageId: "notTemplate",
                target: node,
            }));
        }
        if (sym.node.kind === SyntaxKind.TemplateParameterDeclaration) {
            const type = checkTemplateParameterDeclaration(sym.node);
            // TODO: could cache this probably.
            return type;
        }
        // types for non-templated types
        if (symbolLinks.type) {
            return symbolLinks.type;
        }
        const type = getTypeForNode(sym.node);
        symbolLinks.type = type;
        return type;
    }
    /**
     * Builds a model type from a template and its template arguments.
     * Adds the template node to a set we can check when we bind template
     * parameters to access type type arguments.
     *
     * This will fall over if the same template is ever being instantiated
     * twice at the same time, or if template parameters from more than one template
     * are ever in scope at once.
     */
    function instantiateTemplate(templateNode, args) {
        const symbolLinks = getSymbolLinks(templateNode.symbol);
        const cached = symbolLinks.instantiations.get(args);
        if (cached) {
            return cached;
        }
        const oldTis = templateInstantiation;
        const oldTemplate = instantiatingTemplate;
        templateInstantiation = args;
        instantiatingTemplate = templateNode;
        const type = getTypeForNode(templateNode);
        symbolLinks.instantiations.set(args, type);
        if (type.kind === "Model") {
            type.templateNode = templateNode;
        }
        templateInstantiation = oldTis;
        instantiatingTemplate = oldTemplate;
        return type;
    }
    function checkUnionExpression(node) {
        const options = node.options.flatMap((o) => {
            const type = getTypeForNode(o);
            if (type.kind === "Union" && type.expression) {
                return Array.from(type.variants.entries());
            }
            return [[Symbol(), type]];
        });
        const type = {
            kind: "Union",
            node,
            get options() {
                return Array.from(this.variants.values());
            },
            expression: true,
            variants: new Map(options),
            decorators: [],
        };
        createType(type);
        return type;
    }
    function allModelTypes(types) {
        return types.every((t) => t.kind === "Model");
    }
    /**
     * Intersection produces a model type from the properties of its operands.
     * So this doesn't work if we don't have a known set of properties (e.g.
     * with unions). The resulting model is anonymous.
     */
    function checkIntersectionExpression(node) {
        const optionTypes = node.options.map(getTypeForNode);
        if (!allModelTypes(optionTypes)) {
            program.reportDiagnostic(createDiagnostic({ code: "intersect-non-model", target: node }));
            return errorType;
        }
        const properties = new Map();
        for (const option of optionTypes) {
            const allProps = walkPropertiesInherited(option);
            for (const prop of allProps) {
                if (properties.has(prop.name)) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "intersect-duplicate-property",
                        format: { propName: prop.name },
                        target: node,
                    }));
                    continue;
                }
                const newPropType = createType({
                    ...prop,
                    sourceProperty: prop,
                });
                properties.set(prop.name, newPropType);
            }
        }
        const intersection = createType({
            kind: "Model",
            node,
            name: "",
            properties: properties,
            decorators: [], // could probably include both sets of decorators here...
        });
        return intersection;
    }
    function checkArrayExpression(node) {
        return createType({
            kind: "Array",
            node,
            elementType: getTypeForNode(node.elementType),
        });
    }
    function checkNamespace(node) {
        const links = getSymbolLinks(getMergedSymbol(node.symbol));
        let type = links.type;
        if (!type) {
            type = initializeTypeForNamespace(node);
        }
        if (Array.isArray(node.statements)) {
            node.statements.forEach(getTypeForNode);
        }
        else if (node.statements) {
            const subNs = checkNamespace(node.statements);
            type.namespaces.set(subNs.name, subNs);
        }
        return type;
    }
    function initializeTypeForNamespace(node) {
        compilerAssert(node.symbol, "Namespace is unbound.", node);
        const symbolLinks = getSymbolLinks(getMergedSymbol(node.symbol));
        if (!symbolLinks.type) {
            // haven't seen this namespace before
            const namespace = getParentNamespaceType(node);
            const name = node.name.sv;
            const decorators = checkDecorators(node);
            const type = createType({
                kind: "Namespace",
                name,
                namespace,
                node,
                models: new Map(),
                operations: new Map(),
                namespaces: new Map(),
                interfaces: new Map(),
                unions: new Map(),
                decorators,
            });
            namespace === null || namespace === void 0 ? void 0 : namespace.namespaces.set(name, type);
            symbolLinks.type = type;
        }
        else {
            compilerAssert(symbolLinks.type.kind === "Namespace", "Got non-namespace type when resolving namespace");
            // seen it before, need to execute the decorators on this node
            // against the type we've already made.
            symbolLinks.type.kind;
            const newDecorators = checkDecorators(node);
            symbolLinks.type.decorators.push(...newDecorators);
            for (const dec of newDecorators) {
                symbolLinks.type.decorators.push(dec);
                applyDecoratorToType(dec, symbolLinks.type);
            }
        }
        return symbolLinks.type;
    }
    function getParentNamespaceType(node) {
        if (node === globalNamespaceType.node)
            return undefined;
        if (!node.namespaceSymbol)
            return globalNamespaceType;
        const mergedSymbol = getMergedSymbol(node.namespaceSymbol);
        const symbolLinks = getSymbolLinks(mergedSymbol);
        if (!symbolLinks.type) {
            // in general namespaces should be typed before anything calls this function.
            // However, one case where this is not true is when a decorator on a namespace
            // refers to a model in another namespace. In this case, we need to evaluate
            // the namespace here.
            symbolLinks.type = initializeTypeForNamespace(mergedSymbol.node);
        }
        return symbolLinks.type;
    }
    function checkOperation(node) {
        const namespace = getParentNamespaceType(node);
        const name = node.id.sv;
        const decorators = checkDecorators(node);
        const type = {
            kind: "Operation",
            name,
            namespace,
            node,
            parameters: getTypeForNode(node.parameters),
            returnType: getTypeForNode(node.returnType),
            decorators,
        };
        if (node.parent.kind !== SyntaxKind.InterfaceStatement ||
            shouldCreateTypeForTemplate(node.parent)) {
        }
        if (node.parent.kind === SyntaxKind.InterfaceStatement) {
            if (shouldCreateTypeForTemplate(node.parent)) {
                createType(type);
            }
        }
        else {
            createType(type);
            namespace === null || namespace === void 0 ? void 0 : namespace.operations.set(name, type);
        }
        return type;
    }
    function getGlobalNamespaceType() {
        return globalNamespaceType;
    }
    function getGlobalNamespaceNode() {
        return globalNamespaceNode;
    }
    function checkTupleExpression(node) {
        return createType({
            kind: "Tuple",
            node: node,
            values: node.values.map((v) => getTypeForNode(v)),
        });
    }
    function getSymbolLinks(s) {
        const id = getSymbolId(s);
        if (symbolLinks.has(id)) {
            return symbolLinks.get(id);
        }
        const links = {};
        symbolLinks.set(id, links);
        return links;
    }
    function getSymbolId(s) {
        if (s.id === undefined) {
            s.id = currentSymbolId++;
        }
        return s.id;
    }
    function resolveIdentifierInTable(node, table, resolveDecorator = false) {
        let sym;
        if (resolveDecorator) {
            sym = table.get("@" + node.sv);
        }
        else {
            sym = table.get(node.sv);
        }
        return getMergedSymbol(sym);
    }
    function resolveIdentifier(node, resolveDecorator = false) {
        if (hasParseError(node)) {
            // Don't report synthetic identifiers used for parser error recovery.
            // The parse error is the root cause and will already have been logged.
            return undefined;
        }
        let scope = node.parent;
        let binding;
        while (scope && scope.kind !== SyntaxKind.CadlScript) {
            if ("exports" in scope) {
                const mergedSymbol = getMergedSymbol(scope.symbol);
                binding = resolveIdentifierInTable(node, mergedSymbol.node.exports, resolveDecorator);
                if (binding)
                    return binding;
            }
            if ("locals" in scope) {
                binding = resolveIdentifierInTable(node, scope.locals, resolveDecorator);
                if (binding)
                    return binding;
            }
            scope = scope.parent;
        }
        if (!binding && scope && scope.kind === SyntaxKind.CadlScript) {
            // check any blockless namespace decls
            for (const ns of scope.inScopeNamespaces) {
                const mergedSymbol = getMergedSymbol(ns.symbol);
                binding = resolveIdentifierInTable(node, mergedSymbol.node.exports, resolveDecorator);
                if (binding)
                    return binding;
            }
            // check "global scope" declarations
            binding = resolveIdentifierInTable(node, globalNamespaceNode.exports, resolveDecorator);
            if (binding)
                return binding;
            // check "global scope" usings
            binding = resolveIdentifierInTable(node, scope.locals, resolveDecorator);
            if (binding)
                return binding;
        }
        program.reportDiagnostic(createDiagnostic({ code: "unknown-identifier", format: { id: node.sv }, target: node }));
        return undefined;
    }
    function resolveTypeReference(node, resolveDecorator = false) {
        if (node.kind === SyntaxKind.TypeReference) {
            return resolveTypeReference(node.target, resolveDecorator);
        }
        if (node.kind === SyntaxKind.MemberExpression) {
            const base = resolveTypeReference(node.base);
            if (!base) {
                return undefined;
            }
            if (base.kind === "type" && base.node.kind === SyntaxKind.NamespaceStatement) {
                const symbol = resolveIdentifierInTable(node.id, base.node.exports, resolveDecorator);
                if (!symbol) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-ref",
                        messageId: "underNamespace",
                        format: { id: node.id.sv },
                        target: node,
                    }));
                    return undefined;
                }
                return symbol;
            }
            else if (base.kind === "decorator") {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "inDecorator",
                    format: { id: node.id.sv },
                    target: node,
                }));
                return undefined;
            }
            else {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "node",
                    format: { id: node.id.sv, nodeName: SyntaxKind[base.node.kind] },
                    target: node,
                }));
                return undefined;
            }
        }
        if (node.kind === SyntaxKind.Identifier) {
            return resolveIdentifier(node, resolveDecorator);
        }
        compilerAssert(false, "Unknown type reference kind", node);
    }
    function checkStringLiteral(str) {
        return getLiteralType(str);
    }
    function checkNumericLiteral(num) {
        return getLiteralType(num);
    }
    function checkBooleanLiteral(bool) {
        return getLiteralType(bool);
    }
    function checkProgram() {
        program.reportDuplicateSymbols(globalNamespaceNode.exports);
        for (const file of program.sourceFiles.values()) {
            program.reportDuplicateSymbols(file.locals);
            for (const ns of file.namespaces) {
                program.reportDuplicateSymbols(ns.locals);
                program.reportDuplicateSymbols(ns.exports);
                initializeTypeForNamespace(ns);
            }
        }
        for (const file of program.sourceFiles.values()) {
            checkSourceFile(file);
        }
    }
    function checkSourceFile(file) {
        for (const statement of file.statements) {
            getTypeForNode(statement);
        }
    }
    function checkModel(node) {
        if (node.kind === SyntaxKind.ModelStatement) {
            return checkModelStatement(node);
        }
        else {
            return checkModelExpression(node);
        }
    }
    function checkModelStatement(node) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        const instantiatingThisTemplate = instantiatingTemplate === node;
        if (links.declaredType && !instantiatingThisTemplate) {
            // we're not instantiating this model and we've already checked it
            return links.declaredType;
        }
        const isBase = checkModelIs(node.is);
        const decorators = [];
        if (isBase) {
            // copy decorators
            decorators.push(...isBase.decorators);
        }
        decorators.push(...checkDecorators(node));
        const properties = new Map();
        if (isBase) {
            for (const prop of isBase.properties.values()) {
                properties.set(prop.name, createType({
                    ...prop,
                }));
            }
        }
        let baseModels;
        if (isBase) {
            baseModels = isBase.baseModel;
        }
        else if (node.extends) {
            baseModels = checkClassHeritage(node.extends);
        }
        const type = {
            kind: "Model",
            name: node.id.sv,
            node: node,
            properties,
            baseModel: baseModels,
            namespace: getParentNamespaceType(node),
            decorators,
        };
        // Hold on to the model type that's being defined so that it
        // can be referenced
        pendingModelType = {
            id: node.id,
            type,
        };
        const inheritedPropNames = new Set(Array.from(walkPropertiesInherited(type)).map((v) => v.name));
        // Evaluate the properties after
        checkModelProperties(node, properties, inheritedPropNames);
        if (shouldCreateTypeForTemplate(node)) {
            createType(type);
        }
        if (!instantiatingThisTemplate) {
            links.declaredType = type;
            links.instantiations = new TypeInstantiationMap();
            (_a = type.namespace) === null || _a === void 0 ? void 0 : _a.models.set(type.name, type);
        }
        // The model is fully created now
        pendingModelType = undefined;
        return type;
    }
    function shouldCreateTypeForTemplate(node) {
        const instantiatingThisTemplate = instantiatingTemplate === node;
        return ((instantiatingThisTemplate &&
            templateInstantiation.every((t) => t.kind !== "TemplateParameter")) ||
            node.templateParameters.length === 0);
    }
    function checkModelExpression(node) {
        const properties = new Map();
        checkModelProperties(node, properties);
        const type = createType({
            kind: "Model",
            name: "",
            node: node,
            properties,
            decorators: [],
        });
        return type;
    }
    function checkModelProperties(node, properties, inheritedPropertyNames) {
        for (const prop of node.properties) {
            if ("id" in prop) {
                const newProp = getTypeForNode(prop);
                defineProperty(properties, newProp, inheritedPropertyNames);
            }
            else {
                // spread property
                const newProperties = checkSpreadProperty(prop.target);
                for (const newProp of newProperties) {
                    defineProperty(properties, newProp, inheritedPropertyNames);
                }
            }
        }
    }
    function defineProperty(properties, newProp, inheritedPropertyNames) {
        if (properties.has(newProp.name)) {
            program.reportDiagnostic(createDiagnostic({
                code: "duplicate-property",
                format: { propName: newProp.name },
                target: newProp,
            }));
            return;
        }
        if (inheritedPropertyNames === null || inheritedPropertyNames === void 0 ? void 0 : inheritedPropertyNames.has(newProp.name)) {
            program.reportDiagnostic(createDiagnostic({
                code: "override-property",
                format: { propName: newProp.name },
                target: newProp,
            }));
            return;
        }
        properties.set(newProp.name, newProp);
    }
    function checkClassHeritage(heritageRef) {
        const heritageType = getTypeForNode(heritageRef);
        if (isErrorType(heritageType)) {
            compilerAssert(program.hasError(), "Should already have reported an error.", heritageRef);
            return undefined;
        }
        if (heritageType.kind !== "Model") {
            program.reportDiagnostic(createDiagnostic({ code: "extend-model", target: heritageRef }));
            return undefined;
        }
        return heritageType;
    }
    function checkModelIs(isExpr) {
        if (!isExpr)
            return undefined;
        const isType = getTypeForNode(isExpr);
        if (isType.kind !== "Model") {
            program.reportDiagnostic(createDiagnostic({ code: "is-model", target: isExpr }));
            return;
        }
        return isType;
    }
    function checkSpreadProperty(targetNode) {
        const props = [];
        const targetType = getTypeForNode(targetNode);
        if (targetType.kind != "TemplateParameter") {
            if (targetType.kind !== "Model") {
                program.reportDiagnostic(createDiagnostic({ code: "spread-model", target: targetNode }));
                return props;
            }
            // copy each property
            for (const prop of walkPropertiesInherited(targetType)) {
                const newProp = cloneType(prop, { sourceProperty: prop });
                props.push(newProp);
            }
        }
        return props;
    }
    function* walkPropertiesInherited(model) {
        let current = model;
        while (current) {
            yield* current.properties.values();
            current = current.baseModel;
        }
    }
    function checkModelProperty(prop) {
        const decorators = checkDecorators(prop);
        const valueType = getTypeForNode(prop.value);
        const defaultValue = prop.default && checkDefault(getTypeForNode(prop.default), valueType);
        const name = prop.id.kind === SyntaxKind.Identifier ? prop.id.sv : prop.id.value;
        let type = {
            kind: "ModelProperty",
            name,
            node: prop,
            optional: prop.optional,
            type: valueType,
            decorators,
            default: defaultValue,
        };
        const parentModel = prop.parent;
        if (parentModel.kind !== SyntaxKind.ModelStatement ||
            shouldCreateTypeForTemplate(parentModel)) {
            createType(type);
        }
        return type;
    }
    function checkDefault(defaultType, type) {
        switch (type.kind) {
            case "Model":
                return checkDefaultForModelType(defaultType, type);
            case "Array":
                return checkDefaultForArrayType(defaultType, type);
            default:
                program.reportDiagnostic(createDiagnostic({
                    code: "unsupported-default",
                    format: { type: type.kind },
                    target: defaultType,
                }));
        }
        return errorType;
    }
    function checkDefaultForModelType(defaultType, type) {
        switch (type.name) {
            case "string":
                return checkDefaultTypeIsString(defaultType);
            case "boolean":
                return checkDefaultTypeIsBoolean(defaultType);
            case "int32":
            case "int64":
            case "int32":
            case "int16":
            case "int8":
            case "uint64":
            case "uint32":
            case "uint16":
            case "uint8":
            case "safeint":
            case "float32":
            case "float64":
                return checkDefaultTypeIsNumeric(defaultType);
            default:
                program.reportDiagnostic(createDiagnostic({
                    code: "unsupported-default",
                    format: { type: type.name },
                    target: defaultType,
                }));
        }
        return errorType;
    }
    function checkDefaultForArrayType(defaultType, type) {
        if (defaultType.kind === "Tuple") {
            for (const item of defaultType.values) {
                checkDefault(item, type.elementType);
            }
        }
        else {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-default-type",
                format: { type: "tuple" },
                target: defaultType,
            }));
        }
        return defaultType;
    }
    function checkDefaultTypeIsString(defaultType) {
        if (defaultType.kind !== "String") {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-default-type",
                format: { type: "string" },
                target: defaultType,
            }));
        }
        return defaultType;
    }
    function checkDefaultTypeIsNumeric(defaultType) {
        if (defaultType.kind !== "Number") {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-default-type",
                format: { type: "number" },
                target: defaultType,
            }));
        }
        return defaultType;
    }
    function checkDefaultTypeIsBoolean(defaultType) {
        if (defaultType.kind !== "Boolean") {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-default-type",
                format: { type: "boolean" },
                target: defaultType,
            }));
        }
        return defaultType;
    }
    function checkDecorators(node) {
        const decorators = [];
        for (const decNode of node.decorators) {
            const sym = resolveTypeReference(decNode.target, true);
            if (!sym) {
                program.reportDiagnostic(createDiagnostic({
                    code: "unknown-decorator",
                    target: decNode,
                }));
                continue;
            }
            if (sym.kind !== "decorator") {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-decorator",
                    format: { id: sym.name },
                    target: decNode,
                }));
                continue;
            }
            const args = decNode.arguments.map(getTypeForNode).map((type) => {
                if (type.kind === "Number" || type.kind === "String" || type.kind === "Boolean") {
                    return type.value;
                }
                return type;
            });
            decorators.unshift({
                decorator: sym.value,
                args,
            });
        }
        return decorators;
    }
    function checkAlias(node) {
        const links = getSymbolLinks(node.symbol);
        const instantiatingThisTemplate = instantiatingTemplate === node;
        if (links.declaredType && !instantiatingThisTemplate) {
            return links.declaredType;
        }
        const type = getTypeForNode(node.value);
        if (!instantiatingThisTemplate) {
            links.declaredType = type;
            links.instantiations = new TypeInstantiationMap();
        }
        return type;
    }
    function checkEnum(node) {
        const links = getSymbolLinks(node.symbol);
        if (!links.type) {
            const decorators = checkDecorators(node);
            const enumType = {
                kind: "Enum",
                name: node.id.sv,
                node,
                members: [],
                namespace: getParentNamespaceType(node),
                decorators,
            };
            const memberNames = new Set();
            for (const member of node.members) {
                const memberType = checkEnumMember(enumType, member, memberNames);
                if (memberType) {
                    memberNames.add(memberType.name);
                    enumType.members.push(memberType);
                }
            }
            createType(enumType);
            links.type = enumType;
        }
        return links.type;
    }
    function checkInterface(node) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        const instantiatingThisTemplate = instantiatingTemplate === node;
        if (links.declaredType && !instantiatingThisTemplate) {
            // we're not instantiating this interface and we've already checked it
            return links.declaredType;
        }
        const decorators = checkDecorators(node);
        const interfaceType = {
            kind: "Interface",
            decorators,
            node,
            namespace: getParentNamespaceType(node),
            operations: new Map(),
            name: node.id.sv,
        };
        for (const mixinNode of node.mixes) {
            const mixinType = getTypeForNode(mixinNode);
            if (mixinType.kind !== "Interface") {
                program.reportDiagnostic(createDiagnostic({ code: "mixes-interface", target: mixinNode }));
                continue;
            }
            for (const newMember of mixinType.operations.values()) {
                if (interfaceType.operations.has(newMember.name)) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "mixes-interface-duplicate",
                        format: { name: newMember.name },
                        target: mixinNode,
                    }));
                }
                interfaceType.operations.set(newMember.name, cloneType(newMember));
            }
        }
        const ownMembers = new Map();
        checkInterfaceMembers(node, ownMembers);
        for (const [k, v] of ownMembers) {
            // don't do a duplicate check here because interface members can override
            // an member coming from a mixin.
            interfaceType.operations.set(k, v);
        }
        if ((instantiatingThisTemplate &&
            templateInstantiation.every((t) => t.kind !== "TemplateParameter")) ||
            node.templateParameters.length === 0) {
            createType(interfaceType);
        }
        if (!instantiatingThisTemplate) {
            links.declaredType = interfaceType;
            links.instantiations = new TypeInstantiationMap();
            (_a = interfaceType.namespace) === null || _a === void 0 ? void 0 : _a.interfaces.set(interfaceType.name, interfaceType);
        }
        return interfaceType;
    }
    function checkInterfaceMembers(node, members) {
        for (const opNode of node.operations) {
            const opType = checkOperation(opNode);
            if (members.has(opType.name)) {
                program.reportDiagnostic(createDiagnostic({
                    code: "interface-duplicate",
                    format: { name: opType.name },
                    target: opNode,
                }));
                continue;
            }
            members.set(opType.name, opType);
        }
    }
    function checkUnion(node) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        const instantiatingThisTemplate = instantiatingTemplate === node;
        if (links.declaredType && !instantiatingThisTemplate) {
            // we're not instantiating this interface and we've already checked it
            return links.declaredType;
        }
        const decorators = checkDecorators(node);
        const variants = new Map();
        checkUnionVariants(node, variants);
        const unionType = {
            kind: "Union",
            decorators,
            node,
            namespace: getParentNamespaceType(node),
            name: node.id.sv,
            variants,
            get options() {
                return Array.from(this.variants.values());
            },
            expression: false,
        };
        if ((instantiatingThisTemplate &&
            templateInstantiation.every((t) => t.kind !== "TemplateParameter")) ||
            node.templateParameters.length === 0) {
            createType(unionType);
        }
        if (!instantiatingThisTemplate) {
            links.declaredType = unionType;
            links.instantiations = new TypeInstantiationMap();
            (_a = unionType.namespace) === null || _a === void 0 ? void 0 : _a.unions.set(unionType.name, unionType);
        }
        return unionType;
    }
    function checkUnionVariants(union, variants) {
        for (const variantNode of union.options) {
            const variantType = checkUnionVariant(variantNode);
            if (variants.has(variantType.name)) {
                program.reportDiagnostic(createDiagnostic({
                    code: "union-duplicate",
                    format: { name: variantType.name.toString() },
                    target: variantNode,
                }));
                continue;
            }
            variants.set(variantType.name, variantType);
        }
    }
    function checkUnionVariant(variantNode) {
        const name = variantNode.id.kind === SyntaxKind.Identifier ? variantNode.id.sv : variantNode.id.value;
        const decorators = checkDecorators(variantNode);
        const type = getTypeForNode(variantNode.value);
        return createType({
            kind: "UnionVariant",
            name,
            node: variantNode,
            decorators,
            type,
        });
    }
    function checkEnumMember(parentEnum, node, existingMemberNames) {
        const name = node.id.kind === SyntaxKind.Identifier ? node.id.sv : node.id.value;
        const value = node.value ? node.value.value : undefined;
        const decorators = checkDecorators(node);
        if (existingMemberNames.has(name)) {
            program.reportDiagnostic(createDiagnostic({
                code: "enum-member-duplicate",
                format: { name: name },
                target: node,
            }));
            return;
        }
        return createType({
            kind: "EnumMember",
            enum: parentEnum,
            name,
            node,
            value,
            decorators,
        });
    }
    // the types here aren't ideal and could probably be refactored.
    function createType(typeDef) {
        typeDef.templateArguments = templateInstantiation;
        if ("decorators" in typeDef) {
            for (const decApp of typeDef.decorators) {
                applyDecoratorToType(decApp, typeDef);
            }
        }
        return typeDef;
    }
    function applyDecoratorToType(decApp, target) {
        compilerAssert("decorators" in target, "Cannot apply decorator to non-decoratable type", target);
        // peel `fn` off to avoid setting `this`.
        try {
            const fn = decApp.decorator;
            fn(program, target, ...decApp.args);
        }
        catch (error) {
            // do not fail the language server for exceptions in decorators
            if (program.compilerOptions.designTimeBuild) {
                program.reportDiagnostic(createDiagnostic({
                    code: "decorator-fail",
                    format: { decoratorName: decApp.decorator.name, error },
                    target,
                }));
            }
            else {
                throw error;
            }
        }
    }
    function getLiteralType(node) {
        let type = program.literalTypes.get(node.value);
        if (type) {
            return type;
        }
        switch (node.kind) {
            case SyntaxKind.StringLiteral:
                type = { kind: "String", node, value: node.value };
                break;
            case SyntaxKind.NumericLiteral:
                type = { kind: "Number", node, value: node.value };
                break;
            case SyntaxKind.BooleanLiteral:
                type = { kind: "Boolean", node, value: node.value };
                break;
        }
        program.literalTypes.set(node.value, type);
        return type;
    }
    function mergeSymbolTable(source, target) {
        for (const dupe of source.duplicates) {
            target.duplicates.add(dupe);
        }
        for (const [key, sourceBinding] of source) {
            if (sourceBinding.kind === "type" &&
                sourceBinding.node.kind === SyntaxKind.NamespaceStatement) {
                // we are merging a namespace symbol. See if is an existing namespace symbol
                // to merge with.
                let existingBinding = target.get(key);
                if (!existingBinding) {
                    existingBinding = {
                        kind: "type",
                        node: sourceBinding.node,
                        name: sourceBinding.name,
                        id: sourceBinding.id,
                    };
                    target.set(key, existingBinding);
                    mergedSymbols.set(sourceBinding, existingBinding);
                }
                else if (existingBinding.kind === "type" &&
                    existingBinding.node.kind === SyntaxKind.NamespaceStatement) {
                    mergedSymbols.set(sourceBinding, existingBinding);
                    // merge the namespaces
                    mergeSymbolTable(sourceBinding.node.exports, existingBinding.node.exports);
                }
                else {
                    target.set(key, sourceBinding);
                }
            }
            else {
                target.set(key, sourceBinding);
            }
        }
    }
    function getMergedSymbol(sym) {
        if (!sym)
            return sym;
        return mergedSymbols.get(sym) || sym;
    }
    function getMergedNamespace(node) {
        const sym = getMergedSymbol(node.symbol);
        return sym.node;
    }
    function createGlobalNamespaceNode() {
        const nsId = {
            kind: SyntaxKind.Identifier,
            pos: 0,
            end: 0,
            sv: "__GLOBAL_NS",
        };
        return {
            kind: SyntaxKind.NamespaceStatement,
            decorators: [],
            pos: 0,
            end: 0,
            name: nsId,
            locals: createSymbolTable(),
            exports: createSymbolTable(),
        };
    }
    function createGlobalNamespaceType() {
        return createType({
            kind: "Namespace",
            name: "",
            node: globalNamespaceNode,
            models: new Map(),
            operations: new Map(),
            namespaces: new Map(),
            interfaces: new Map(),
            unions: new Map(),
            decorators: [],
        });
    }
    function cloneType(type, additionalProps = {}) {
        return createType({
            ...type,
            ...additionalProps,
        });
    }
    /**
     * useful utility function to debug the scopes produced by the binder,
     * the result of symbol merging, and identifier resolution.
     */
    function dumpScope(scope = globalNamespaceNode, indent = 0) {
        if (scope.locals) {
            console.log(`${Array(indent * 2).join(" ")}-locals:`);
            for (const [name, sym] of scope.locals) {
                console.log(`${Array(indent * 2 + 1).join(" ")}${name} => ${sym.kind === "type" ? SyntaxKind[sym.node.kind] : "[fn]"}`);
            }
        }
        console.log(`${Array(indent * 2).join(" ")}-exports:`);
        for (const [name, sym] of scope.exports) {
            console.log(`${Array(indent * 2 + 1).join(" ")}${name} => ${sym.kind === "type" ? SyntaxKind[sym.node.kind] : "[fn]"}`);
            if (sym.kind === "type" && sym.node.kind == SyntaxKind.NamespaceStatement) {
                dumpScope(sym.node, indent + 1);
            }
        }
    }
}
function isErrorType(type) {
    return type.kind === "Intrinsic" && type.name === "ErrorType";
}
//# sourceMappingURL=checker.js.map