import prettier from "prettier";
import { SyntaxKind, } from "../../core/types.js";
const { align, breakParent, concat, group, hardline, ifBreak, indent, join, line, softline } = prettier.doc.builders;
const { isNextLineEmpty } = prettier.util;
const { replaceNewlinesWithLiterallines } = prettier.doc.utils;
export const cadlPrinter = {
    print: printCadl,
    canAttachComment: canAttachComment,
    printComment: printComment,
};
export function printCadl(
// Path to the AST node to print
path, options, print) {
    const directives = printDirectives(path, options, print);
    const node = printNode(path, options, print);
    return concat([directives, node]);
}
export function printNode(
// Path to the AST node to print
path, options, print) {
    const node = path.getValue();
    printDirectives(path, options, print);
    switch (node.kind) {
        // Root
        case SyntaxKind.CadlScript:
            return concat([
                printStatementSequence(path, options, print, "statements"),
                line,
            ]);
        // Statements
        case SyntaxKind.ImportStatement:
            return concat([`import "${node.path.value}";`]);
        case SyntaxKind.UsingStatement:
            return concat([`using `, path.call(print, "name"), `;`]);
        case SyntaxKind.OperationStatement:
            return printOperationStatement(path, options, print);
        case SyntaxKind.NamespaceStatement:
            return printNamespaceStatement(path, options, print);
        case SyntaxKind.ModelStatement:
            return printModelStatement(path, options, print);
        case SyntaxKind.AliasStatement:
            return printAliasStatement(path, options, print);
        case SyntaxKind.EnumStatement:
            return printEnumStatement(path, options, print);
        case SyntaxKind.UnionStatement:
            return printUnionStatement(path, options, print);
        case SyntaxKind.InterfaceStatement:
            return printInterfaceStatement(path, options, print);
        // Others.
        case SyntaxKind.Identifier:
            return node.sv;
        case SyntaxKind.StringLiteral:
            return printStringLiteral(path, options);
        case SyntaxKind.NumericLiteral:
            return printNumberLiteral(path, options);
        case SyntaxKind.ModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.DecoratorExpression:
            return printDecorator(path, options, print);
        case SyntaxKind.DirectiveExpression:
            return printDirective(path, options, print);
        case SyntaxKind.UnionExpression:
            return printUnion(path, options, print);
        case SyntaxKind.IntersectionExpression:
            return printIntersection(path, options, print);
        case SyntaxKind.EnumMember:
            return printEnumMember(path, options, print);
        case SyntaxKind.UnionVariant:
            return printUnionVariant(path, options, print);
        case SyntaxKind.TypeReference:
            return printTypeReference(path, options, print);
        default:
            return getRawText(node, options);
    }
}
export function printAliasStatement(path, options, print) {
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    return concat(["alias ", id, template, " = ", path.call(print, "value"), ";"]);
}
function printTemplateParameters(path, options, print, propertyName) {
    const value = path.getValue()[propertyName];
    if (value.length === 0) {
        return "";
    }
    return concat(["<", join(", ", path.map(print, propertyName)), ">"]);
}
export function canAttachComment(node) {
    const kind = node.kind;
    return Boolean(kind && kind !== SyntaxKind.LineComment && kind !== SyntaxKind.BlockComment);
}
export function printComment(commentPath, options) {
    const comment = commentPath.getValue();
    switch (comment.kind) {
        case SyntaxKind.BlockComment:
            return printBlockComment(commentPath, options);
        case SyntaxKind.LineComment:
            return `${options.originalText.slice(comment.pos, comment.end).trimRight()}`;
        default:
            throw new Error(`Not a comment: ${JSON.stringify(comment)}`);
    }
}
function printBlockComment(commentPath, options) {
    const comment = commentPath.getValue();
    const rawComment = options.originalText.slice(comment.pos + 2, comment.end - 2);
    if (isIndentableBlockComment(rawComment)) {
        const printed = printIndentableBlockComment(rawComment);
        return printed;
    }
    return concat(["/*", replaceNewlinesWithLiterallines(rawComment), "*/"]);
}
function isIndentableBlockComment(rawComment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    const lines = `*${rawComment}*`.split("\n");
    return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");
}
function printIndentableBlockComment(rawComment) {
    const lines = rawComment.split("\n");
    return concat([
        "/*",
        join(hardline, lines.map((line, index) => index === 0
            ? line.trimEnd()
            : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))),
        "*/",
    ]);
}
export function printDecorators(path, options, print, { tryInline }) {
    const node = path.getValue();
    if (node.decorators.length === 0) {
        return { decorators: "", multiline: false };
    }
    const shouldBreak = !tryInline || node.decorators.length >= 3 || hasNewlineBetweenOrAfterDecorators(node, options);
    const decorators = path.map((x) => concat([print(x), ifBreak(line, " ")]), "decorators");
    return {
        decorators: group(concat([shouldBreak ? breakParent : "", decorators])),
        multiline: shouldBreak,
    };
}
/**
 * Check if there is already new lines in between the decorators of the node.
 */
function hasNewlineBetweenOrAfterDecorators(node, options) {
    return node.decorators.some((decorator) => prettier.util.hasNewline(options.originalText, decorator.end));
}
export function printDecorator(path, options, print) {
    const args = printDecoratorArgs(path, options, print);
    return concat(["@", path.call(print, "target"), args]);
}
export function printDirectives(path, options, print) {
    const node = path.getValue();
    if (node.directives === undefined || node.directives.length === 0) {
        return "";
    }
    const directives = path.map((x) => concat([print(x), line]), "directives");
    return group(concat([...directives, breakParent]));
}
export function printDirective(path, options, print) {
    const args = printDirectiveArgs(path, options, print);
    return concat(["#", path.call(print, "target"), " ", args]);
}
function printDecoratorArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    // So that decorator with single object arguments have ( and { hugging.
    // @deco({
    //   value: "foo"
    // })
    const shouldHug = node.arguments.length === 1 && node.arguments[0].kind === SyntaxKind.ModelExpression;
    if (shouldHug) {
        return concat([
            "(",
            join(", ", path.map((arg) => concat([print(arg)]), "arguments")),
            ")",
        ]);
    }
    return concat([
        "(",
        group(concat([
            indent(join(", ", path.map((arg) => concat([softline, print(arg)]), "arguments"))),
            softline,
        ])),
        ")",
    ]);
}
export function printDirectiveArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    return join(" ", path.map((arg) => concat([print(arg)]), "arguments"));
}
export function printEnumStatement(path, options, print) {
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const id = path.call(print, "id");
    return concat([decorators, "enum ", id, " ", printEnumBlock(path, options, print)]);
}
function printEnumBlock(path, options, print) {
    const node = path.getValue();
    if (node.members.length === 0) {
        return "{}";
    }
    return group(concat([
        "{",
        indent(concat([
            hardline,
            join(hardline, path.map((x) => concat([print(x), ","]), "members")),
        ])),
        hardline,
        "}",
    ]));
}
export function printEnumMember(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const value = node.value ? concat([": ", path.call(print, "value")]) : "";
    const { decorators } = printDecorators(path, options, print, { tryInline: true });
    return concat([decorators, id, value]);
}
export function printUnionStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return concat([
        decorators,
        "union ",
        id,
        generic,
        " ",
        printUnionVariantsBlock(path, options, print),
    ]);
}
export function printUnionVariantsBlock(path, options, print) {
    const node = path.getValue();
    if (node.options.length === 0) {
        return "{}";
    }
    return group(concat([
        "{",
        indent(concat([
            hardline,
            join(hardline, path.map((x) => concat([print(x), ","]), "options")),
        ])),
        hardline,
        "}",
    ]));
}
export function printUnionVariant(path, options, print) {
    const id = path.call(print, "id");
    const value = concat([": ", path.call(print, "value")]);
    const { decorators } = printDecorators(path, options, print, { tryInline: true });
    return concat([decorators, id, value]);
}
export function printInterfaceStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return concat([
        decorators,
        "interface ",
        id,
        generic,
        " ",
        printInterfaceMembers(path, options, print),
    ]);
}
export function printInterfaceMembers(path, options, print) {
    const node = path.getValue();
    if (node.operations.length === 0) {
        return "{}";
    }
    return group(concat([
        "{",
        indent(concat([
            hardline,
            join(hardline, path.map((x) => print(x), "operations")),
        ])),
        hardline,
        "}",
    ]));
}
/**
 * Handle printing an intersection node.
 * @example `Foo & Bar` or `{foo: string} & {bar: string}`
 *
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier child print callback.
 * @returns Prettier document.
 */
export function printIntersection(path, options, print) {
    const node = path.getValue();
    const types = path.map(print, "options");
    const result = [];
    let wasIndented = false;
    for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
            result.push(types[i]);
        }
        else if (isModelNode(node.options[i - 1]) && isModelNode(node.options[i])) {
            // If both are objects, don't indent
            result.push(concat([" & ", wasIndented ? indent(types[i]) : types[i]]));
        }
        else if (!isModelNode(node.options[i - 1]) && !isModelNode(node.options[i])) {
            // If no object is involved, go to the next line if it breaks
            result.push(indent(concat([" &", line, types[i]])));
        }
        else {
            // If you go from object to non-object or vis-versa, then inline it
            if (i > 1) {
                wasIndented = true;
            }
            result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
        }
    }
    return group(concat(result));
}
function isModelNode(node) {
    return node.kind === SyntaxKind.ModelExpression;
}
export function printModelExpression(path, options, print) {
    const inBlock = isModelExpressionInBlock(path);
    if (inBlock) {
        return group(printModelPropertiesBlock(path, options, print));
    }
    else {
        return group(concat([
            indent(join(", ", path.map((arg) => concat([softline, print(arg)]), "properties"))),
            softline,
        ]));
    }
}
export function printModelStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const heritage = node.extends ? concat(["extends ", path.call(print, "extends"), " "]) : "";
    const isBase = node.is ? concat(["is ", path.call(print, "is"), " "]) : "";
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return concat([
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "model ",
        id,
        generic,
        " ",
        heritage,
        isBase,
        printModelPropertiesBlock(path, options, print),
    ]);
}
function printModelPropertiesBlock(path, options, print) {
    const node = path.getNode();
    if (!(node === null || node === void 0 ? void 0 : node.properties) || node.properties.length === 0) {
        return "{}";
    }
    const seperator = isModelAValue(path) ? "," : ";";
    return concat([
        "{",
        indent(concat([
            hardline,
            join(hardline, path.map((x) => concat([print(x), seperator]), "properties")),
        ])),
        hardline,
        "}",
    ]);
}
/**
 * Figure out if this model is being used as a definition or value.
 * @returns true if the model is used as a value(e.g. decorator value), false if it is used as a model definition.
 */
function isModelAValue(path) {
    let count = 0;
    let node = path.getValue();
    do {
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
            case SyntaxKind.AliasStatement:
                return false;
            case SyntaxKind.DecoratorExpression:
                return true;
        }
    } while ((node = path.getParentNode(count++)));
    return true;
}
export function printModelProperty(path, options, print) {
    const node = path.getValue();
    const propertyIndex = path.stack[path.stack.length - 2];
    const isNotFirst = typeof propertyIndex === "number" && propertyIndex > 0;
    const { decorators, multiline } = printDecorators(path, options, print, {
        tryInline: true,
    });
    return concat([
        multiline && isNotFirst ? hardline : "",
        decorators,
        path.call(print, "id"),
        node.optional ? "?: " : ": ",
        path.call(print, "value"),
        node.default ? concat([" = ", path.call(print, "default")]) : "",
    ]);
}
function isModelExpressionInBlock(path) {
    const parent = path.getParentNode();
    switch (parent === null || parent === void 0 ? void 0 : parent.kind) {
        case SyntaxKind.OperationStatement:
            return false;
        default:
            return true;
    }
}
export function printNamespaceStatement(path, options, print) {
    const printNested = (currentPath, parentNames) => {
        var _a;
        const names = [...parentNames, currentPath.call(print, "name")];
        const currentNode = currentPath.getNode();
        if (!Array.isArray(currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) &&
            ((_a = currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamespaceStatement) {
            return path.call((x) => printNested(x, names), "statements");
        }
        const suffix = (currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === undefined
            ? ";"
            : concat([
                " {",
                indent(concat([hardline, printStatementSequence(path, options, print, "statements")])),
                hardline,
                "}",
            ]);
        const { decorators } = printDecorators(path, options, print, { tryInline: false });
        return concat([decorators, `namespace `, join(".", names), suffix]);
    };
    return printNested(path, []);
}
export function printOperationStatement(path, options, print) {
    var _a;
    const inInterface = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.InterfaceStatement;
    const { decorators } = printDecorators(path, options, print, {
        tryInline: true,
    });
    return concat([
        decorators,
        inInterface ? "" : "op ",
        path.call(print, "id"),
        "(",
        path.call(print, "parameters"),
        "): ",
        path.call(print, "returnType"),
        `;`,
    ]);
}
export function printStatementSequence(path, options, print, property) {
    const node = path.getValue();
    const parts = [];
    const lastStatement = getLastStatement(node[property]);
    path.each((statementPath) => {
        const node = path.getValue();
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        if (node !== lastStatement) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, property);
    return concat(parts);
}
function getLastStatement(statements) {
    for (let i = statements.length - 1; i >= 0; i--) {
        const statement = statements[i];
        if (statement.kind !== SyntaxKind.EmptyStatement) {
            return statement;
        }
    }
    return undefined;
}
export function printUnion(path, options, print) {
    const node = path.getValue();
    const shouldHug = shouldHugType(node);
    const types = path.map((typePath) => {
        let printedType = print(typePath);
        if (!shouldHug) {
            printedType = align(2, printedType);
        }
        return printedType;
    }, "options");
    if (shouldHug) {
        return join(" | ", types);
    }
    const shouldAddStartLine = true;
    const code = [
        ifBreak(concat([shouldAddStartLine ? line : "", "| "]), ""),
        join(concat([line, "| "]), types),
    ];
    return group(indent(concat(code)));
}
function shouldHugType(node) {
    if (node.kind === SyntaxKind.UnionExpression || node.kind === SyntaxKind.IntersectionExpression) {
        return node.options.length < 4;
    }
    return false;
}
export function printTypeReference(path, options, print) {
    const type = path.call(print, "target");
    const template = printTemplateParameters(path, options, print, "arguments");
    return concat([type, template]);
}
export function printStringLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
export function printNumberLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
/**
 * @param node Node that has postition information.
 * @param options Prettier options
 * @returns Raw text in the file for the given node.
 */
function getRawText(node, options) {
    return options.originalText.slice(node.pos, node.end);
}
//# sourceMappingURL=printer.js.map