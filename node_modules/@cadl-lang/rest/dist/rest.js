import { createCadlLibrary, paramMessage, } from "@cadl-lang/compiler";
const libDefinition = {
    name: "@cadl-lang/rest",
    diagnostics: {
        "service-title-namespace-only": {
            severity: "error",
            messages: {
                default: "The @serviceTitle decorator can only be applied to namespaces.",
            },
        },
        "service-title-duplicate": {
            severity: "error",
            messages: {
                default: "Service title can only be set once per Cadl document.",
            },
        },
        "service-host-duplicate": {
            severity: "error",
            messages: {
                default: "Service host can only be set once per Cadl document.",
            },
        },
        "service-host-namespace-only": {
            severity: "error",
            messages: {
                default: "The @serviceHost decorator can only be applied to namespaces.",
            },
        },
        "service-version-duplicate": {
            severity: "error",
            messages: {
                default: "Service version can only be set once per Cadl document.",
            },
        },
        "service-version-namespace-only": {
            severity: "error",
            messages: {
                default: "The @serviceVersion decorator can only be applied to namespaces.",
            },
        },
        "produces-namespace-only": {
            severity: "error",
            messages: {
                default: "The @produces decorator can only be applied to namespaces.",
            },
        },
        "consumes-namespace-only": {
            severity: "error",
            messages: {
                default: "The @consumes decorator can only be applied to namespaces.",
            },
        },
        "service-namespace-duplicate": {
            severity: "error",
            messages: {
                default: "Cannot set service namespace more than once in an Cadl project.",
            },
        },
        "http-verb-duplicate": {
            severity: "error",
            messages: {
                default: paramMessage `HTTP verb already applied to ${"entityName"}`,
            },
        },
        "http-verb-wrong-type": {
            severity: "error",
            messages: {
                default: paramMessage `Cannot use @${"verb"} on a ${"entityKind"}`,
            },
        },
    },
};
export const restLib = createCadlLibrary(libDefinition);
const { reportDiagnostic } = restLib;
const basePathsKey = Symbol();
export function getHttpOperation(program, operation) {
    if (!operation.namespace || !isResource(program, operation.namespace)) {
        return undefined;
    }
    return {
        basePath: basePathForResource(program, operation),
        route: getOperationRoute(program, operation),
        kind: operation.kind,
        name: operation.name,
        node: operation.node,
        returnType: operation.returnType,
        namespace: operation.namespace,
        parameters: operation.parameters,
        decorators: operation.decorators,
    };
}
export function $resource(program, entity, basePath = "") {
    if (entity.kind !== "Namespace")
        return;
    program.stateMap(basePathsKey).set(entity, basePath);
}
export function getResources(program) {
    return Array.from(program.stateMap(basePathsKey).keys());
}
export function isResource(program, obj) {
    return program.stateMap(basePathsKey).has(obj);
}
export function basePathForResource(program, resource) {
    return program.stateMap(basePathsKey).get(resource);
}
const headerFieldsKey = Symbol();
export function $header(program, entity, headerName) {
    if (!headerName && entity.kind === "ModelProperty") {
        headerName = entity.name.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    }
    program.stateMap(headerFieldsKey).set(entity, headerName);
}
export function getHeaderFieldName(program, entity) {
    return program.stateMap(headerFieldsKey).get(entity);
}
export function isHeader(program, entity) {
    return program.stateMap(headerFieldsKey).has(entity);
}
const queryFieldsKey = Symbol();
export function $query(program, entity, queryKey) {
    if (!queryKey && entity.kind === "ModelProperty") {
        queryKey = entity.name;
    }
    program.stateMap(queryFieldsKey).set(entity, queryKey);
}
export function getQueryParamName(program, entity) {
    return program.stateMap(queryFieldsKey).get(entity);
}
export function isQueryParam(program, entity) {
    return program.stateMap(queryFieldsKey).has(entity);
}
const pathFieldsKey = Symbol();
export function $path(program, entity, paramName) {
    if (!paramName && entity.kind === "ModelProperty") {
        paramName = entity.name;
    }
    program.stateMap(pathFieldsKey).set(entity, paramName);
}
export function getPathParamName(program, entity) {
    return program.stateMap(pathFieldsKey).get(entity);
}
export function isPathParam(program, entity) {
    return program.stateMap(pathFieldsKey).has(entity);
}
const bodyFieldsKey = Symbol();
export function $body(program, entity) {
    program.stateSet(bodyFieldsKey).add(entity);
}
export function isBody(program, entity) {
    return program.stateSet(bodyFieldsKey).has(entity);
}
const operationRoutesKey = Symbol();
function setOperationRoute(program, entity, verb) {
    if (entity.kind === "Operation") {
        if (!program.stateMap(operationRoutesKey).has(entity)) {
            program.stateMap(operationRoutesKey).set(entity, verb);
        }
        else {
            reportDiagnostic(program, {
                code: "http-verb-duplicate",
                format: { entityName: entity.name },
                target: entity,
            });
        }
    }
    else {
        reportDiagnostic(program, {
            code: "http-verb-wrong-type",
            format: { verb: verb.verb, entityKind: entity.kind },
            target: entity,
        });
    }
}
export function getOperationRoute(program, entity) {
    return program.stateMap(operationRoutesKey).get(entity);
}
export function $get(program, entity, subPath) {
    setOperationRoute(program, entity, {
        verb: "get",
        subPath,
    });
}
export function $put(program, entity, subPath) {
    setOperationRoute(program, entity, {
        verb: "put",
        subPath,
    });
}
export function $post(program, entity, subPath) {
    setOperationRoute(program, entity, {
        verb: "post",
        subPath,
    });
}
export function $patch(program, entity, subPath) {
    setOperationRoute(program, entity, {
        verb: "patch",
        subPath,
    });
}
export function $delete(program, entity, subPath) {
    setOperationRoute(program, entity, {
        verb: "delete",
        subPath,
    });
}
const programServiceDetails = new WeakMap();
function getServiceDetails(program) {
    let serviceDetails = programServiceDetails.get(program);
    if (!serviceDetails) {
        serviceDetails = {};
        programServiceDetails.set(program, serviceDetails);
    }
    return serviceDetails;
}
export function setServiceNamespace(program, namespace) {
    const serviceDetails = getServiceDetails(program);
    if (serviceDetails.namespace && serviceDetails.namespace !== namespace) {
        reportDiagnostic(program, { code: "service-namespace-duplicate", target: namespace });
    }
    serviceDetails.namespace = namespace;
}
export function checkIfServiceNamespace(program, namespace) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.namespace === namespace;
}
export function $serviceTitle(program, entity, title) {
    const serviceDetails = getServiceDetails(program);
    if (serviceDetails.title) {
        reportDiagnostic(program, { code: "service-title-duplicate", target: entity });
    }
    if (entity.kind !== "Namespace") {
        reportDiagnostic(program, {
            code: "service-title-namespace-only",
            target: entity,
        });
        return;
    }
    setServiceNamespace(program, entity);
    serviceDetails.title = title;
}
export function getServiceTitle(program) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.title || "(title)";
}
export function $serviceHost(program, entity, host) {
    const serviceDetails = getServiceDetails(program);
    if (serviceDetails.version) {
        reportDiagnostic(program, { code: "service-version-duplicate", target: entity });
    }
    if (entity.kind !== "Namespace") {
        reportDiagnostic(program, { code: "service-version-namespace-only", target: entity });
        return;
    }
    setServiceNamespace(program, entity);
    serviceDetails.host = host;
}
export function getServiceHost(program) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.host;
}
export function setServiceHost(program, host) {
    const serviceDetails = getServiceDetails(program);
    serviceDetails.host = host;
}
export function $serviceVersion(program, entity, version) {
    const serviceDetails = getServiceDetails(program);
    // TODO: This will need to change once we support multiple service versions
    if (serviceDetails.version) {
        reportDiagnostic(program, { code: "service-version-duplicate", target: entity });
    }
    if (entity.kind !== "Namespace") {
        reportDiagnostic(program, { code: "service-version-namespace-only", target: entity });
        return;
    }
    setServiceNamespace(program, entity);
    serviceDetails.version = version;
}
export function getServiceVersion(program) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.version || "0000-00-00";
}
export function getServiceNamespaceString(program) {
    const serviceDetails = getServiceDetails(program);
    return ((serviceDetails.namespace && program.checker.getNamespaceString(serviceDetails.namespace)) ||
        undefined);
}
const producesTypesKey = Symbol();
export function $produces(program, entity, ...contentTypes) {
    if (entity.kind !== "Namespace") {
        reportDiagnostic(program, { code: "produces-namespace-only", target: entity });
    }
    const values = getProduces(program, entity);
    program.stateMap(producesTypesKey).set(entity, values.concat(contentTypes));
}
export function getProduces(program, entity) {
    return program.stateMap(producesTypesKey).get(entity) || [];
}
const consumesTypesKey = Symbol();
export function $consumes(program, entity, ...contentTypes) {
    if (entity.kind !== "Namespace") {
        reportDiagnostic(program, { code: "consumes-namespace-only", target: entity });
    }
    const values = getConsumes(program, entity);
    program.stateMap(consumesTypesKey).set(entity, values.concat(contentTypes));
}
export function getConsumes(program, entity) {
    return program.stateMap(consumesTypesKey).get(entity) || [];
}
//# sourceMappingURL=rest.js.map